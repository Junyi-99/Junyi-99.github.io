<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"military-doctor.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Junyi的小屋">
<meta property="og:url" content="https://military-doctor.github.io/page/2/index.html">
<meta property="og:site_name" content="Junyi的小屋">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Junyi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://military-doctor.github.io/page/2/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Junyi的小屋</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junyi的小屋</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">30</span></a></li>
        <li class="menu-item menu-item-imwpc2021"><a href="/2021imwpc/" rel="section"><i class="fa fa-chess fa-fw"></i>2021 IMWPC</a></li>
        <li class="menu-item menu-item-friends"><a href="/friends/" rel="section"><i class="fa fa-user-friends fa-fw"></i>友情链接</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Junyi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Junyi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Military-Doctor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Military-Doctor" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/09/28/2020-09-28-%E7%94%B5%E5%8A%A8%E8%BD%A6%E8%A2%AB%E5%81%B7%E4%BA%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/28/2020-09-28-%E7%94%B5%E5%8A%A8%E8%BD%A6%E8%A2%AB%E5%81%B7%E4%BA%86/" class="post-title-link" itemprop="url">他妈的！电动自行车被偷了！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-28 01:11:23" itemprop="dateCreated datePublished" datetime="2020-09-28T01:11:23+08:00">2020-09-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 14:20:41" itemprop="dateModified" datetime="2021-03-08T14:20:41+08:00">2021-03-08</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天他妈的电动自行车被人偷了！</p>
<p>艹！</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/28/2020-09-28-%E7%94%B5%E5%8A%A8%E8%BD%A6%E8%A2%AB%E5%81%B7%E4%BA%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/08/04/2020-08-04-FEC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/04/2020-08-04-FEC/" class="post-title-link" itemprop="url">FEC - 前向纠错技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-04 15:19:38" itemprop="dateCreated datePublished" datetime="2020-08-04T15:19:38+08:00">2020-08-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 16:13:53" itemprop="dateModified" datetime="2021-03-08T16:13:53+08:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">未分类</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>FEC：Forward Error Correction，前向纠错</p>
<blockquote>
<p> FEC 是一种通过在网络传输中增加数据包的冗余信息，使得接收端能够在网络发生丢包后利用这些冗余信息直接恢复出丢失的数据包的一种方法。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104579290">https://zhuanlan.zhihu.com/p/104579290</a></p>
</blockquote>
<h3 id="Parity-Check-奇偶校验"><a href="#Parity-Check-奇偶校验" class="headerlink" title="Parity Check 奇偶校验"></a>Parity Check 奇偶校验</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 例如：求 10100001 中 1 的数量是奇数还是偶数</span><br><span class="line">// 结果为 1 就是奇数个 1，结果为 0 就是偶数个 1</span><br><span class="line">1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1   </span><br></pre></td></tr></table></figure>

<p>每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位<strong>粗略地判断</strong>接收到的数据是否有误。</p>
<h3 id="基于-XOR-的-FEC"><a href="#基于-XOR-的-FEC" class="headerlink" title="基于 XOR 的 FEC"></a>基于 XOR 的 FEC</h3><p>假设网络通信有 N 个 packet 需要发送，那么可以每 2 个 packet 生成一个 FEC packet，这样，连续的 3 个 packet 的任意一个 packet 丢失，都能通过另外 2 个恢复出来。</p>
<p>但考虑到每 2 个 packet 就产生 1 个 fec packet，冗余度可能有点高（比较浪费带宽），我们能否每 3 个或者每 N 个 packet 再产生一个 fec packet 呢？当然可以，我们以每 3 个 packet（A、B、C） 产生 1 个 fec packet（D）为例来推导一下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = a ^ b ^ c</span><br><span class="line">a = a ^ (b ^ b) ^ (c ^ c) = (b ^ c) ^ (a ^ b ^ c) = b ^ c ^ d</span><br><span class="line">b = (a ^ a) ^ b ^ (c ^ c) = (a ^ c) ^ (a ^ b ^ c) = a ^ c ^ d</span><br><span class="line">c = (a ^ a) ^ (b ^ b) ^ c = (a ^ b) ^ (a ^ b ^ c) = a ^ b ^ d</span><br></pre></td></tr></table></figure>

<p>由上述公式推导即可知道，这 4 个 packet，任意丢失 1 个 packet，均可以由其他 3 个 packet 恢复出来。</p>
<h3 id="对象存储-EC纠删码"><a href="#对象存储-EC纠删码" class="headerlink" title="对象存储-EC纠删码"></a>对象存储-EC纠删码</h3><p>通过 K个有效数据，产生 M 个 FEC 冗余包，这 K + M 个数据，任意丢失 M 个数据，都能把 K 个有效数据恢复出来。</p>
<h3 id="Reed-Solomon-Codes"><a href="#Reed-Solomon-Codes" class="headerlink" title="Reed-Solomon Codes"></a>Reed-Solomon Codes</h3><h1 id="RFC-草案-Payload-Flexible-FEC"><a href="#RFC-草案-Payload-Flexible-FEC" class="headerlink" title="RFC 草案 Payload Flexible FEC"></a>RFC 草案 Payload Flexible FEC</h1><h2 id="1-1-奇偶校验码"><a href="#1-1-奇偶校验码" class="headerlink" title="1.1 奇偶校验码"></a>1.1 奇偶校验码</h2><h3 id="1-1-1-一维-Parity-FEC-Protection"><a href="#1-1-1-一维-Parity-FEC-Protection" class="headerlink" title="1.1.1 一维 Parity FEC Protection"></a>1.1.1 一维 Parity FEC Protection</h3><p>非交错，按行生成，一行里丢一个包可以，丢两个就没法恢复了（Burst Loss）</p>
<p>一维连续FEC保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 1 |    X      X    | 4 |  |R_1|</span><br><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 5 |  | 6 |  | 7 |  | 8 |  |R_2|</span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 9 |  | 10|  | 11|  | 12|  |R_3|</span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非交错，按列生成，一列里丢一个包可以，丢两个就没法恢复了（Periodic Loss）</p>
<p>一维隔行FEC保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---+         +---+  +---+</span><br><span class="line">| 1 |    X    | 3 |  | 4 |</span><br><span class="line">+---+         +---+  +---+</span><br><span class="line"></span><br><span class="line">+---+         +---+  +---+</span><br><span class="line">| 5 |    X    | 7 |  | 8 |</span><br><span class="line">+---+         +---+  +---+</span><br><span class="line"></span><br><span class="line">+---+  +---+  +---+  +---+</span><br><span class="line">| 9 |  | 10|  | 11|  | 12|</span><br><span class="line">+---+  +---+  +---+  +---+</span><br><span class="line"></span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|C_1|  |C_2|  |C_3|  |C_4|</span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br></pre></td></tr></table></figure>



<h3 id="1-1-2-二维-Parity-FEC-Protection"><a href="#1-1-2-二维-Parity-FEC-Protection" class="headerlink" title="1.1.2 二维 Parity FEC Protection"></a>1.1.2 二维 Parity FEC Protection</h3><p>互联网丢包是随机的、爆发式的，发送端应该生成 non-interleaved 和 interleaved 前项纠错包（FEC packets）</p>
<p>这种 FEC 保护被称作 <strong>二维奇偶校验前向纠错保护</strong></p>
<p>但是如果发生特定的 loss pattern，这种保护模式依然会失效，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 1 |    X      X    | 4 |  |R_1|</span><br><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 5 |  | 6 |  | 7 |  | 8 |  |R_2|</span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 9 |    X      X    | 12|  |R_3|</span><br><span class="line">+---+                +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|C_1|  |C_2|  |C_3|  |C_4|</span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+---+  +---+         +---+</span><br><span class="line">| 1 |  | 2 |    X    | 4 |    X</span><br><span class="line">+---+  +---+         +---+</span><br><span class="line"></span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| 5 |  | 6 |  | 7 |  | 8 |  |R_2|</span><br><span class="line">+---+  +---+  +---+  +---+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br><span class="line">+---+  +---+         +---+</span><br><span class="line">| 9 |  | 10|    X    | 12|    X</span><br><span class="line">+---+  +---+         +---+</span><br><span class="line"></span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line">|C_1|  |C_2|  |C_3|  |C_4|</span><br><span class="line">+&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+  +&#x3D;&#x3D;&#x3D;+</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-1-3-开销计算-Overhead-Computation"><a href="#1-1-3-开销计算-Overhead-Computation" class="headerlink" title="1.1.3 开销计算 Overhead Computation"></a>1.1.3 开销计算 Overhead Computation</h3><p>开销（overhead）被定义为：</p>
<p>修复包大小 / 源包大小</p>
<p>单位：Bytes</p>
<p>通常来说，修复包比源包更大。</p>
<p>如果我们假设每一个修复包携带与源包等量的bytes，我们可以计算出每一个不同的FEC保护策略的开销：</p>
<p>一维连续FEC保护：开销=1/L</p>
<p>一维隔行FEC保护：开销 = 1/D</p>
<p>二维 FEC 保护：开销 = 1/L + 1/D</p>
<p>   where L and D are the number of columns and rows in the source block,<br>   respectively.</p>
<h1 id="3-定义"><a href="#3-定义" class="headerlink" title="3. 定义"></a>3. 定义</h1><p>L：表示列</p>
<p>D：表示行</p>
<p>bitmask：由FEC包保护的包的运行长度编码。如果掩码中的位i被设置为1，源数据包的编号N + i被这个FEC包保护。这里，N是数基数，FEC包中也有表示。</p>
<h1 id="4-包格式"><a href="#4-包格式" class="headerlink" title="4. 包格式"></a>4. 包格式</h1><p>这一小节定义了源包和修复包的格式</p>
<h2 id="4-1-源包"><a href="#4-1-源包" class="headerlink" title="4.1 源包"></a>4.1 源包</h2><h2 id="4-2-修复包"><a href="#4-2-修复包" class="headerlink" title="4.2 修复包"></a>4.2 修复包</h2><p>修复包必须包含标识它们所属的源块的信息，以及包含的修复符号与原始源块之间的关系。为此，我们使用修复包的RTP报头以及RTP有效负载中的另一个报头，我们将其称为FEC报头，如图9所示。</p>
<p>（注意，受特定FEC包保护的所有源流包都需要在同一个RTP会话中。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          IP Header           |</span><br><span class="line">+------------------------------+</span><br><span class="line">|       Transport Header       |</span><br><span class="line">+------------------------------+</span><br><span class="line">|          RTP Header          | __</span><br><span class="line">+------------------------------+   |</span><br><span class="line">|          FEC Header          |    \</span><br><span class="line">+------------------------------+     &gt; RTP Payload</span><br><span class="line">|        Repair Symbols        |    &#x2F;</span><br><span class="line">+------------------------------+ __|</span><br></pre></td></tr></table></figure>



<p>Marker (M) Bit: 应该被设置成 0 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|R|F| P|X|  CC   |M| PT recovery |         length recovery      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          TS recovery                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|   SSRCCount   |                    reserved                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             SSRC_i                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           SN base_i           |k|          Mask [0-14]        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                   Mask [15-45] (optional)                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                                                             |</span><br><span class="line">+-+                   Mask [46-108] (optional)                  |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     ... next in SSRC_i ...                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>





<h1 id="8-拥塞控制考虑"><a href="#8-拥塞控制考虑" class="headerlink" title="8.拥塞控制考虑"></a>8.拥塞控制考虑</h1><p>in networks where the congestion is a major contributor to the packet loss, the potential impacts of using FEC SHOULD be considered carefully before injecting the repair flows into the network.</p>
<p>In particular, in bandwidth-limited networks, FEC repair flows may consume most or all of the available bandwidth and consequently may congest the network.  In such cases, the applications MUST NOT arbitrarily increase the amount of FEC protection since doing so may lead to a congestion collapse. If desired, stronger FEC protection MAY be applied only after the source rate has been reduced.</p>
<h1 id="9-安全性考虑"><a href="#9-安全性考虑" class="headerlink" title="9.安全性考虑"></a>9.安全性考虑</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/08/02/2020-08-02-Payload_Flexible_FEC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/02/2020-08-02-Payload_Flexible_FEC/" class="post-title-link" itemprop="url">RFC8627 - Payload Flexible FEC 翻译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-02 11:08:57" itemprop="dateCreated datePublished" datetime="2020-08-02T11:08:57+08:00">2020-08-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 16:11:12" itemprop="dateModified" datetime="2021-03-08T16:11:12+08:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">未分类</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Payload-Flexible-FEC"><a href="#Payload-Flexible-FEC" class="headerlink" title="Payload Flexible FEC"></a>Payload Flexible FEC</h1><h1 id="3-Definitions-and-Notations"><a href="#3-Definitions-and-Notations" class="headerlink" title="3. Definitions and Notations"></a>3. Definitions and Notations</h1><h2 id="3-1-Definitions"><a href="#3-1-Definitions" class="headerlink" title="3.1 Definitions"></a>3.1 Definitions</h2><h2 id="3-2-Notations"><a href="#3-2-Notations" class="headerlink" title="3.2 Notations"></a>3.2 Notations</h2><h1 id="4-Packet-Formats-包格式"><a href="#4-Packet-Formats-包格式" class="headerlink" title="4. Packet Formats 包格式"></a>4. Packet Formats 包格式</h1><p>这一节定义了源包和修复包的格式</p>
<h2 id="4-1-Source-Packets-源包"><a href="#4-1-Source-Packets-源包" class="headerlink" title="4.1. Source Packets 源包"></a>4.1. Source Packets 源包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The source packets MUST contain the information that identifies the</span><br><span class="line">source block and the position within the source block occupied by the</span><br><span class="line">packet.  Since the source packets that are carried within an RTP</span><br><span class="line">stream already contain unique sequence numbers in their RTP headers</span><br><span class="line">[RFC3550], we can identify the source packets in a straightforward</span><br><span class="line">manner and there is no need to append additional field(s).  The</span><br><span class="line">primary advantage of not modifying the source packets in any way is</span><br><span class="line">that it provides backward compatibility for the receivers that do not</span><br><span class="line">support FEC at all.  In multicast scenarios, this backward</span><br><span class="line">compatibility becomes quite useful as it allows the non-FEC-capable</span><br><span class="line">and FEC-capable receivers to receive and interpret the same source</span><br><span class="line">packets sent in the same multicast session.</span><br></pre></td></tr></table></figure>



<h2 id="4-2-Repair-Packets-修复包"><a href="#4-2-Repair-Packets-修复包" class="headerlink" title="4.2. Repair Packets 修复包"></a>4.2. Repair Packets 修复包</h2><p>修复包中必须有能够区分 source block they pertain to 和 the relationship between the contained repair symbols and the original source block.</p>
<p>针对这个要求，修复包使用 RTP 的头，以及 RTP 载荷中的另一个头，我们把它叫做 FEC 头，具体请看 Figure 9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          IP Header           |</span><br><span class="line">+------------------------------+</span><br><span class="line">|       Transport Header       |</span><br><span class="line">+------------------------------+</span><br><span class="line">|          RTP Header          | __</span><br><span class="line">+------------------------------+   |</span><br><span class="line">|          FEC Header          |    \</span><br><span class="line">+------------------------------+     &gt; RTP Payload</span><br><span class="line">|        Repair Symbols        |    &#x2F;</span><br><span class="line">+------------------------------+ __|</span><br><span class="line"></span><br><span class="line">        Figure 9: Format of repair packets</span><br></pre></td></tr></table></figure>

<p>注意，被 FEC 保护的所有 包，必须在同一个 RTP session 里</p>
<p>RTP 的头部根据 RFC3550 所定义，添加了进一步的 clarifications：</p>
<ul>
<li>Marker (M) Bit：这个 bit 不是给这个 payload type 用的，所以应该被设置成 0</li>
<li>Payload Type：修复包的(动态)载荷类型由带外方式确定。根据 RFC3550 中的定义，RTP接受者收到不能识别的PayloadType包时，会将整个包丢掉。这个特点提供了后向兼容性。如果一个不支持 FEC 的接受者收到了修复包，它将不能识别修复包的 payload type，从而丢掉修复包</li>
<li>Sequence Number（SN）：序列号有一个标准的定义，它的值必须大于上次传输修复包所用的值。初始值应该是随机生成的（不可预测的）</li>
<li>Timestamp（TS）：是叫戳应该被设置成修复包被传输时的时间。这个时间戳不是用来给 FEC 做纠错用的，通常是给 jitter calculation 用的。</li>
<li>Synchronization Source（SSRC）：根据 RFC3550，这个 SSRC 值应该被随机分配。这允许发送者在同一个端口复用源包和修复包，或者在同一端口复用多个修复包。<strong>修复流</strong> SHOULD 使用 RTCP CNAME 字段把自己跟<strong>源流</strong>关联。在一些网络里，同时产生源包和修复包的RTP源可能不是同一个主机。在这个场景里，给源流和修复流使用同样的 CNAME 意味着RTP源和FEC源必须共享同一个 CNAME。基于一个已知的算法和RTP、FEC源，一个公共的 CNAME 可能被产生（RFC7022）。这个用法符合 RFC3550 中的定义。<font color="red"><strong>注意，由于是随机分配 SSRC，这里有可能会造成 SSRC 冲突。发生冲突时，必须按照 RFC3550 中的定义去解决冲突。</strong></font></li>
</ul>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|R|F| P|X|  CC   |M| PT recovery |         length recovery      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          TS recovery                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|   SSRCCount   |                    reserved                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             SSRC_i                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           SN base_i           |k|          Mask [0-14]        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                   Mask [15-45] (optional)                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                                                             |</span><br><span class="line">+-+                   Mask [46-108] (optional)                  |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     ... next in SSRC_i ...                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">             Figure 10: Format of the FEC header</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>FEC 头部包含以下字段：</p>
<ul>
<li><p>R bit 去表示这是一个重传包的话必须设置成1，<strong>对于修复包必须设置成0</strong></p>
</li>
<li><p>F 字段表示 mask 的类型：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-------------------------------------+</span><br><span class="line">|     F bit     | Use                                 |</span><br><span class="line">+---------------+-------------------------------------+</span><br><span class="line">|       0       | flexible mask                       |</span><br><span class="line">|       1       | packets indicated by offset M and N |</span><br><span class="line">+---------------+-------------------------------------+</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                      Figure 11: F-bit values</span><br></pre></td></tr></table></figure>
</li>
<li><p>P, X, CC, M 和 PT recovery 字段用户确定被恢复包的字段</p>
</li>
<li><p>Length Recovery （16-bit）字段被用来确定恢复包的长度</p>
</li>
<li><p>TS recovery（32-bit）字段被用来确定恢复包的时间戳</p>
</li>
<li><p>SSRC count（8-bit）字段描述了 FEC 包保护的 SSRC 的数量。0不是一个有效值，并且这个包 MUST 被忽略。</p>
</li>
<li><p>Reserved（24-bit）为了未来的用途而被保留。它 MUST 被发送者设置成 0，并且被接受者忽略</p>
</li>
<li><p>SSRC_i（32-bit）字段描述了当前这个特定的 FEC 包保护了哪个 SSRC。如果 FEC 包保护了多个 SSRC（SSRC count &gt; 1），那么这里将会有多个 blocks of data 包含 SSRC, SN base 和 Mask Fields.</p>
</li>
<li><p>SN base_i（16-bit）字段表示此修复包保护的特定 SSRC（在SSRC_i中指示）的源包的最低序号（考虑到回绕）【译者：我不知道什么是回绕 wrap around into account】</p>
</li>
<li><p>如果 F bit 被设置成0，则表示这个特定的修复包所保护的源包的所有 SSRC 使用 flexible bitmask 来处理。对于一个被 FEC 保护的特定的 SSRC_i 包，mask 是一个游程编码（run-length encoding）。第 j 位设置成 1 表示 源包的序列号（SN base_i + j + 1）被这个FEC包所保护。</p>
</li>
<li><p>bitmask中的 k-bit 表示这是一个 15-,46-或109-bitmask。k=0 表示这里有一个以上的 k-bit set，k=1 表示这是 bit mask 中最后一个 block。当解析一个头的时候，当前的 k-bit 数量决定了 bit mask v 的大小：</p>
</li>
<li><p>$$<br>size_of_next_bitmast = 2^{count(k)+3}-1<br>$$</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|0|0| P|X|  CC  |M| PT recovery |         length recovery       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          TS recovery                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|   SSRCCount   |                    reserved                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             SSRC_i                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           SN base_i           |k|          Mask [0-14]        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                   Mask [15-45] (optional)                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|k|                                                             |</span><br><span class="line">+-+                   Mask [46-108] (optional) </span><br><span class="line">|</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     ... next in SSRC_i ...                    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">          Figure 12: Protocol format for F&#x3D;0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 F-bit 被设置成1，它表示被这个特定修复包所保护的源包中的所有 SSRC 使用固定 offset</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|0| P|X|  CC  |M| PT recovery |         length recovery       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          TS recovery                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|   SSRCCount   |                    reserved                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             SSRC_i                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           SN base_i           |  M (columns)  |    N (rows)   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">             Figure 13: Protocol format for F&#x3D;1</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Consequently, the following conditions occur for M and N values:</span><br><span class="line"></span><br><span class="line">If M&gt;0, N&#x3D;0,  is Row FEC, and no column FEC will follow</span><br><span class="line">            Hence, FEC &#x3D; SN, SN+1, SN+2, ... , SN+(M-1), SN+M.</span><br><span class="line"> </span><br><span class="line">If M&gt;0, N&#x3D;1,  is Row FEC, and column FEC will follow.</span><br><span class="line">              Hence, FEC &#x3D; SN, SN+1, SN+2, ... , SN+(M-1), SN+M.</span><br><span class="line">         and more to come</span><br><span class="line"> </span><br><span class="line">If M&gt;0, N&gt;1,  indicates column FEC of every M packet</span><br><span class="line">                 in a group of N packets starting at SN base.</span><br><span class="line">              Hence, FEC &#x3D; SN+(Mx0), SN+(Mx1), ... , SN+(MxN).</span><br><span class="line"></span><br><span class="line">          Figure 14: Interpreting the M and N field values</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过设置 R 为 1，F 为 1，这个 FEC 就只保护一个包了。比如，SN Base_i 表示了FEC 载荷承载着的包，这是一种非常有效的重传包的方法。特别注意的是，解析这种包非常特别。序列号（SN base_i）替代了 FEC 包中 length recovery 字段。SSRC_count 应该为 1，M 和 N 应该为 0，并且 FEC 头的 reserved bits 也不复存在。通过这个方法我们可以省下 64 bits。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|1| P|X|  CC  |M| PT recovery |        sequence number        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           timestamp                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                              SSRC                             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Retransmission                        |</span><br><span class="line">:                            payload                            :</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  </span><br><span class="line">        Figure 15: Protocol format for Retransmission</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在 Section 6.2 里描述了设置这些字段的细节</p>
<p>需要注意的是，mask-based 的方法（与 RFC2733 和 RFC5109 中很相似）可能不是非常有效的指明在当前 source block 中修复包与哪个源包关联。特别的是，对于想使用 large source block size 的应用程序来说，描述源包-修复包 的这个关联，所需的 mask 可能大的令人难以接受。</p>
<p>[SMPTE2022-1]中提出的8位字段指示一种系统化的方法。 相反，本文档中的方法使用8位字段指示受FEC数据包保护的数据包偏移量。 [SMPTE2022-1]中的方法本质上对于常规模式更有效，但不能提供表示其他保护模式的灵活性（比如：staircase）</p>
<h1 id="5-Payload-Format-Parameters-载荷格式参数"><a href="#5-Payload-Format-Parameters-载荷格式参数" class="headerlink" title="5. Payload Format Parameters 载荷格式参数"></a>5. Payload Format Parameters 载荷格式参数</h1><p>这一章节提供了对于非交错和交错的奇偶FEC的媒体子类型注册。这一章也通过这些参数配置 FEC 编码和解码。如果没有特定的 FEC code 被子类型所指明，那么 FEC code 默认是这一章里定义的奇偶码（parity code）。</p>
<h2 id="5-1-Media-Type-Registration-Parity-Codes-媒体类型注册-奇偶码"><a href="#5-1-Media-Type-Registration-Parity-Codes-媒体类型注册-奇偶码" class="headerlink" title="5.1. Media Type Registration - Parity Codes 媒体类型注册 - 奇偶码"></a>5.1. Media Type Registration - Parity Codes 媒体类型注册 - 奇偶码</h2><table>
<thead>
<tr>
<th></th>
<th>audio/flexfec</th>
<th>video/flexfec</th>
<th>text/flexfec</th>
<th>application/flexfec</th>
</tr>
</thead>
<tbody><tr>
<td>Type name</td>
<td>audio</td>
<td>video</td>
<td>text</td>
<td>application</td>
</tr>
<tr>
<td>Subtype name</td>
<td>flexfec</td>
<td>flexfec</td>
<td>flexfec</td>
<td>flexfec</td>
</tr>
<tr>
<td>Required param: rate</td>
<td>The RTP timestamp (clock) rate.  The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Required param: repair-window</td>
<td>The time that spans the source packets and the corresponding repair packets.  The size of the repair window is specified in microseconds.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: L</td>
<td>indicates the number of columns of the source block that are protected by this FEC block and it applies to all the source SSRCs.  L is a positive integer.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: D</td>
<td>indicates the number of rows of the source block that are protected by this FEC block and it applies to all the source SSRCs.  D is a positive integer.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: ToP</td>
<td>indicates the type of protection applied by the sender: 0 for 1-D interleaved FEC protection, 1 for 1-D non-interleaved FEC protection, and 2 for 2-D parity FEC protection.  The ToP value of 3 is reserved for future uses.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Encoding considerations</td>
<td>This media type is framed (See Section 4.8    in the template document [RFC6838]) and contains binary data.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Security considerations</td>
<td>See Section 9 of [RFCXXXX]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Interoperability considerations</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Published specification</td>
<td>[RFCXXXX]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Applications that use this media type:</td>
<td>Multimedia applications that    want to improve resiliency against packet loss by sending redundant    data in addition to the source media.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Fragment identifier considerations:</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Additional information</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Intended usage</td>
<td>COMMON</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Restriction on usage</td>
<td>This media type depends on RTP framing, and    hence, is only defined for transport via RTP [RFC3550]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Provisional registration? (standards tree only)</td>
<td>Yes</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
</tbody></table>
<h2 id="5-2-Mapping-to-SDP-Parameters-到-SDP-参数的映射"><a href="#5-2-Mapping-to-SDP-Parameters-到-SDP-参数的映射" class="headerlink" title="5.2. Mapping to SDP Parameters 到 SDP 参数的映射"></a>5.2. Mapping to SDP Parameters 到 SDP 参数的映射</h2><p>The mapping of the media type specification for “non-interleaved-parityfec” and “interleaved-parityfec” and their parameters in SDP is as follows:</p>
<ul>
<li>The media type (e.g., “application”) goes into the “m=” line as the media name.</li>
<li>The media subtype goes into the “a=rtpmap” line as the encoding name.  The RTP clock rate parameter (“rate”) also goes into the “a=rtpmap” line as the clock rate.</li>
<li>The remaining required payload-format-specific parameters go into the “a=fmtp” line by copying them directly from the media type string as a semicolon-separated list of parameter=value pairs.</li>
</ul>
<p>有关 SDP 的例子请看 Section 7.</p>
<h3 id="5-2-1-Offer-Answer-Model-Considerations"><a href="#5-2-1-Offer-Answer-Model-Considerations" class="headerlink" title="5.2.1. Offer-Answer Model Considerations"></a>5.2.1. Offer-Answer Model Considerations</h3><p>When offering 1-D interleaved parity FEC over RTP using SDP in an Offer/Answer model [RFC3264], the following considerations apply:</p>
<ul>
<li>不同 L 和 D 的组合会产生不同的 FEC 数据，并且无法与其它组合相互使用。发送者可能会想要提供多个有效的 L 和 D 的组合供接收者使用。接收者 SHOULD 正常选择有足够的 interleaving 的 offer。如果多个 offer 存在，接收者可能选择最低开小的或需要最小缓冲区的 offer。具体的选择跟场景要求有关</li>
<li>Repair-window 的值依赖于 L 和 D 的值，不能随便写。更具体的来讲，L 和 D 的值决定了 repair-window 大小的下限（最小值）。repair-window 的上限并不由 L 和 D 来决定。</li>
<li>在相同的 L 和 D 条件下，就算 repair-window 的值不同，也会产生相同的 FEC 数据，不过，不同的 repair-window 和 相同L/D 的组合，仍然被视作不同的 offer。repair-window 会影响到传输源包的最大延迟，因为直接影响到了 receiver 的 buffering 的条件，所以在选择 offer 的时候 receiver 必须考虑延迟。</li>
<li>There are no optional format parameters defined for this payload. Any unknown option in the offer MUST be ignored and deleted from the answer. 如果客户端不想要 FEC，那么 answer 里就会把 FEC 去掉</li>
</ul>
<p>这里说的 offer 指的是 L、D 和 repair-window 的组合</p>
<h3 id="5-2-2-Declarative-Considerations"><a href="#5-2-2-Declarative-Considerations" class="headerlink" title="5.2.2. Declarative Considerations"></a>5.2.2. Declarative Considerations</h3><p>In declarative usage, like SDP in the Real-time Streaming Protocol (RTSP) [RFC2326] or the Session Announcement Protocol (SAP) [RFC2974], the following considerations apply:</p>
<ul>
<li>载荷的格式配置参数全都是声明的，参与者 MUST 使用在session中被提供的配置</li>
<li>通过声明多个 RTP 载荷类型，一个以上的配置可能被提供。在这种情况下，receivers 应当选择一个最适合的 repair flow</li>
</ul>
<h1 id="6-Protection-and-Recovery-Procedures-Parity-Codes-保护和恢复过程-奇偶码"><a href="#6-Protection-and-Recovery-Procedures-Parity-Codes-保护和恢复过程-奇偶码" class="headerlink" title="6. Protection and Recovery Procedures - Parity Codes 保护和恢复过程 - 奇偶码"></a>6. Protection and Recovery Procedures - Parity Codes 保护和恢复过程 - 奇偶码</h1><p>这一章提供了对 1-D 和 2-D 奇偶码的完整定义和它们的 RTP 载荷格式</p>
<h2 id="6-1-Overview-概览"><a href="#6-1-Overview-概览" class="headerlink" title="6.1. Overview 概览"></a>6.1. Overview 概览</h2><p>下面的章节详细介绍了生成修复包、通过修复包重建源包的具体步骤。</p>
<h2 id="6-2-Repair-Packet-Construction-修复包的构造"><a href="#6-2-Repair-Packet-Construction-修复包的构造" class="headerlink" title="6.2. Repair Packet Construction 修复包的构造"></a>6.2. Repair Packet Construction 修复包的构造</h2><p>修复包的头部已经在 Section 4.2 有了详细说明</p>
<p>FEC 的头部包含 12 字节（有可能扩展到 28 字节）。通过对每个源包的每一位进行异或操作来生成特定的修复包。给你一个修复包，那么源包的集合，可以通过 Section 6.3.1 中的公式计算出来。</p>
<p>通过将每个源包按照以下字段的顺序拼接在一起，我们就可以生成 bit string。</p>
<ul>
<li><p>RTP 头部的前 64 bits </p>
</li>
<li><p>无符号网络序的 16-bit 源包字节大小除以12（因为固定的RTP头）。说人话就是网络序的 uin16_t 的变量 = 源包字节数 / 12</p>
<p>比如以下参数的长度和（如果有的话）：CSRC list，extension header, RTP payload 和 RTP padding (16 bits).</p>
</li>
</ul>
<p>通过对源包的 bit string 应用奇偶操作，我们就可以生成 FEC bit string。</p>
<p>FEC 头是从 FEC bit string 按照以下结构生成的：</p>
<ul>
<li>忽略掉 FEC bit string 中的 2 bits 最高有效位。设置 FEC 头的 MSK bits 成合适的值，比如，它跟 bitmask 长度有关</li>
<li>FEC bit string 的下一位 被写入FEC头的 P recovery bit</li>
<li>下 1 位被写入 FEC 头的 X recovery bit</li>
<li>下 4 位被写入 FEC 头的 CC recovery field</li>
<li>下 1 位被写入 FEC 头的 M recovery bit</li>
<li>下 7 位被写入 FEC 头的 PT recovery field</li>
<li>下 16 位被跳过</li>
<li>下 32 位被写入 FEC 头的 TS recovery field</li>
<li>下 16 位被写入 FEC 头的 length recovery field</li>
<li>根据选择的 MSK 值， bit mask of appropriate length will be set to the appropriate values.</li>
</ul>
<p>就像 Section 4.2 中描述的那样，FEC 头部的 SN base field 必须设置成 the lowest sequence number of the source packets protected by this repair packet. 当 MSK 表示一个 bitmask（MSK=00,01,10）的时候，SN base field corresponds to the lowest sequence number indicated in the bitmask. 当 MSK=11，以下的情况：</p>
<ol>
<li>对于 interleaved FEC 包，这对应着源包的最低 sequence number，按照列进行构建</li>
<li>对于 non-interleaved FEC 包，SN base field 必须设置成源包的最低 sequence number，按照行进行构建。</li>
</ol>
<p>修复包的载荷数据包含了源包 XOR 之后的数据。如果源包的载荷长度各不相同，那么短的包必须补零补到长的包那么长。</p>
<p>由于这种可能的 padding 和 强制的 FEC 头，一个修复包的大小要比源包的大。<strong>这可能导致修复包的大小超过 MTU。</strong></p>
<h2 id="6-3-Source-Packet-Reconstruction-重建源包"><a href="#6-3-Source-Packet-Reconstruction-重建源包" class="headerlink" title="6.3. Source Packet Reconstruction 重建源包"></a>6.3. Source Packet Reconstruction 重建源包</h2><p>这一小节描述了重建丢失源包的修复过程。</p>
<p>修复过程有两步：</p>
<ol>
<li>FEC decoder 决定应该使用哪一个源包和修复包来恢复丢失的包</li>
<li>decoder 修复丢失的包，包括 RTP 头部和 RTP 载荷</li>
</ol>
<p>在下面几个小节，我们描述了一些步骤一和步骤二的 RECOMMENDED 的算法。基于这个实现，某些算法可能会被抛弃使用。</p>
<p>然而，最终实现 MUST 与下面的描述一致。</p>
<p>注意，不管 FEC 保护应用在行还是列，1-D 奇偶码所使用的算法相同。而 2-D奇偶码，通常需要多次迭代，这个迭代解码算法被 Section 6.3.4 进一步解释。</p>
<h3 id="6-3-1-Associating-the-Source-and-Repair-Packets-源包与修复包之间的关联"><a href="#6-3-1-Associating-the-Source-and-Repair-Packets-源包与修复包之间的关联" class="headerlink" title="6.3.1. Associating the Source and Repair Packets 源包与修复包之间的关联"></a>6.3.1. Associating the Source and Repair Packets 源包与修复包之间的关联</h3><p>根据<strong>修复包</strong> p<em>，得出<strong>源包</strong>的集合 T(p\</em>)。</p>
<p>注意的是，对于 L 列、 D 行的 source block， 集合 T 包含了 D 个源包 + 一个列修复包，还有 L 个源包 + 一个行修复包</p>
<p>列修复包：通过一列源包计算出来的修复包</p>
<p>行修复包：通过一行源包计算出来的修复包</p>
<p>集合 T 中如果只丢了一个源包，那么数据可以被恢复。如果集合 T 中丢失超过一个源包，那么 1-D FEC protection 将失效。</p>
<h4 id="6-3-1-1-Signaled-in-SDP-在SDP中的交互"><a href="#6-3-1-1-Signaled-in-SDP-在SDP中的交互" class="headerlink" title="6.3.1.1. Signaled in SDP 在SDP中的交互"></a>6.3.1.1. Signaled in SDP 在SDP中的交互</h4><p>第一步是关联源包和修复包。如果 endpoint 整个依赖 out-of-band signaling（MSK=11, M=N=0），可以从 SDP 描述的 media type parameters 推断出这个信息。进一步来讲，RTP 头部的 payload type field 可以辅助 receiver 去 distinguish 交错的或非交错的 FEC 包。</p>
<p>数学上来讲，对于接收到的任意的修复包 p<em>， 我们可以确定出被保护的源包的 sequence number：<br>$$<br>p</em>_snb + i \times {X_1} \left( modulo 65535 \right)<br>$$<br>p*_snb 表示 p* 的 FEC 头，里面的 SN base filed 的。</p>
<p>X_1，如果 FEC 包是交错式的，就被设置成 L，如果是非交错式的，那就是 1<br>$$<br>0 \le i \lt X_2<br>$$<br>X_2，如果 FEC 包是交错式的，就被设置成 D，如果是非交错式的，那就是 L</p>
<h4 id="6-3-1-2-Using-bitmasks"><a href="#6-3-1-2-Using-bitmasks" class="headerlink" title="6.3.1.2. Using bitmasks"></a>6.3.1.2. Using bitmasks</h4><p>当使用固定大小的 bitmasks （16-, 48-, 122-bits）的时候，FEC 头部的 SN base field 表示 lowest sequence number of the 源包 that forms the FEC packet. </p>
<p>bitmask 中的 “1” 其实是从 SN base 开始的 offset，表示被 FEC 保护的剩余 packet。</p>
<p>bitmasks 有能力表示任意的 protection patterns，比如 1-D interleaved，1-D non-interleaved, 2-D, staircase。</p>
<h4 id="6-3-1-3-Using-M-and-Offsets"><a href="#6-3-1-3-Using-M-and-Offsets" class="headerlink" title="6.3.1.3. Using M and Offsets"></a>6.3.1.3. Using M and Offsets</h4><p>当 M 的值非零时，8-bit 的 field 表示由 interleaved（N&gt;0） 或 non-interleaved（N=0） FEC 包所保护的数据包的 offset </p>
<p>通过组合 interleaved 和 non-interleaved FEC包，我们可以组成 2-D protection patterns。</p>
<p>数学上来讲，对于任意接收到的修复包 p*，我们可以通过以下方式确定被保护的源包的 sequence number：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">When N &#x3D; 0:</span><br><span class="line">  p*_snb, p*_snb+1,..., p*_snb+(M-1), p*_snb+M</span><br><span class="line">When N &gt; 0:</span><br><span class="line">  p*_snb, p*_snb+(Mx1), p*_snb+(Mx2),..., p*_snb+(Mx(N-1)), p*_snb+(MxN)</span><br></pre></td></tr></table></figure>



<h3 id="6-3-2-Recovering-the-RTP-Header-恢复-RTP-头"><a href="#6-3-2-Recovering-the-RTP-Header-恢复-RTP-头" class="headerlink" title="6.3.2. Recovering the RTP Header 恢复 RTP 头"></a>6.3.2. Recovering the RTP Header 恢复 RTP 头</h3><p>略过，因为不需要实现</p>
<h1 id="7-SDP-Examples-有关-SDP-的例子"><a href="#7-SDP-Examples-有关-SDP-的例子" class="headerlink" title="7. SDP Examples 有关 SDP 的例子"></a>7. SDP Examples 有关 SDP 的例子</h1><p>这一节，提供了两个 SDP 的例子。例子里使用了在 RFC5956 中定义的 FEC grouping 语义。</p>
<h2 id="7-1-Example-SDP-for-Flexible-FEC-Protection-with-in-band-SSRC-mapping"><a href="#7-1-Example-SDP-for-Flexible-FEC-Protection-with-in-band-SSRC-mapping" class="headerlink" title="7.1. Example SDP for Flexible FEC Protection with in-band SSRC mapping"></a>7.1. Example SDP for Flexible FEC Protection with in-band SSRC mapping</h2><p>在这个例子里，我们有一个视频源流和一个FEC修复包流。源和修复包流被复用在不同的SSRC里。repair-window被设置成 200ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v&#x3D;0</span><br><span class="line">o&#x3D;mo 1122334455 1122334466 IN IP4 fec.example.com</span><br><span class="line">s&#x3D;FlexFEC minimal SDP signalling Example</span><br><span class="line">t&#x3D;0 0</span><br><span class="line">m&#x3D;video 30000 RTP&#x2F;AVP 96 98</span><br><span class="line">c&#x3D;IN IP4 143.163.151.157</span><br><span class="line">a&#x3D;rtpmap:96 VP8&#x2F;90000</span><br><span class="line">a&#x3D;rtpmap:98 flexfec&#x2F;90000</span><br><span class="line">a&#x3D;fmtp:98; repair-window&#x3D;200ms</span><br></pre></td></tr></table></figure>



<h2 id="7-2-Example-SDP-for-Flex-FEC-Protection-with-explicit-signalling-in-the-SDP"><a href="#7-2-Example-SDP-for-Flex-FEC-Protection-with-explicit-signalling-in-the-SDP" class="headerlink" title="7.2. Example SDP for Flex FEC Protection with explicit signalling in the SDP"></a>7.2. Example SDP for Flex FEC Protection with explicit signalling in the SDP</h2><p>在这里例子里，我们有一个视频源流（ssrc：1234）和一个 FEC 修复包流（ssrc：2345）。</p>
<p>我们跟<code>a=ssrc-group:FEC-FR 1234 2345</code>构建一个 FEC groups。源和修复包流复用在不同的 SSRC 里。repair-window 被设置成 200ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v&#x3D;0</span><br><span class="line">o&#x3D;ali 1122334455 1122334466 IN IP4 fec.example.com</span><br><span class="line">s&#x3D;2-D Parity FEC with no in band signalling Example</span><br><span class="line">t&#x3D;0 0</span><br><span class="line">m&#x3D;video 30000 RTP&#x2F;AVP 100 110</span><br><span class="line">c&#x3D;IN IP4 233.252.0.1&#x2F;127</span><br><span class="line">a&#x3D;rtpmap:100 MP2T&#x2F;90000</span><br><span class="line">a&#x3D;rtpmap:110 flexfec&#x2F;90000</span><br><span class="line">a&#x3D;fmtp:110 L:5; D:10; ToP:2; repair-window:200000</span><br><span class="line">a&#x3D;ssrc:1234</span><br><span class="line">a&#x3D;ssrc:2345</span><br><span class="line">a&#x3D;ssrc-group:FEC-FR 1234 2345</span><br></pre></td></tr></table></figure>



<h1 id="8-Congestion-Control-Considerations-拥塞控制的考虑"><a href="#8-Congestion-Control-Considerations-拥塞控制的考虑" class="headerlink" title="8. Congestion Control Considerations 拥塞控制的考虑"></a>8. Congestion Control Considerations 拥塞控制的考虑</h1><p>FEC 为应用层对抗丢包提供了一种有效的方法。然而，如果在一个丢包是因为拥塞控制的网络中，那么在使用 FEC 之前，应该考虑到 FEC 注入到网络中潜在的影响。</p>
<p>特别的是，在带宽限制的网络中，FEC 修复包的流动，可能成为带宽消耗的罪魁祸首，有可能会堵塞网络。在这个情况里，应用程序 MUST NOT 随意增加 FEC 保护的次数，因为这么做会有可能导致拥塞崩溃（Congestion Collapse）。</p>
<p>Congestive collapse (or congestion collapse) is the condition in which congestionprevents or limits useful communication.</p>
<p>如果你真的很想要 FEC 保护，那么你或许可以在源码率降低的时候采用更强的 FEC 保护。</p>
<p>在一个网络友好的实现里，如果应用程序知道 发送/接受 FEC 修复流 并不能帮助恢复丢失的包的时候，应用程序 SHOULD NOT 发送/接收 FEC 修复流。然而，如果考虑用于带宽估计，而不是通过推测方式探寻额外的容量，应用程序 MAY still continue 去使用 FEC。这里 RECOMMENDED 去基于应用程序观察到的丢包率，动态地调整 FEC 保护。</p>
<p>在多播的情景里，为每一个接收端去优化 FEC 保护是非常困难的。如果你有一堆不同的接受者，并且这些接受者都要求使用不同的 FEC 保护级别的话，这里 RECOMMENDED 发送者提供多个修复流，每个修复流都是不同的 FEC 保护级别，让接受者加入对应的多播session 去接收最适合他们的修复流。</p>
<p>编者注：2-D的奇偶码应该也加入到 “多余的拥塞控制考虑” 里</p>
<p>（不是译者注）</p>
<h1 id="9-Security-Considerations-安全考虑"><a href="#9-Security-Considerations-安全考虑" class="headerlink" title="9. Security Considerations 安全考虑"></a>9. Security Considerations 安全考虑</h1><h1 id="10-IANA-Considerations"><a href="#10-IANA-Considerations" class="headerlink" title="10. IANA Considerations"></a>10. IANA Considerations</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">New media subtypes are subject to IANA registration.  For the</span><br><span class="line">registration of the payload formats and their parameters introduced</span><br><span class="line">in this document, refer to Section 5.</span><br></pre></td></tr></table></figure>



<h1 id="11-Acknowledgements"><a href="#11-Acknowledgements" class="headerlink" title="11. Acknowledgements"></a>11. Acknowledgements</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Some parts of this document are borrowed from [RFC5109].  Thus, the</span><br><span class="line">author would like to thank the editor of [RFC5109] and those who</span><br><span class="line">contributed to [RFC5109].</span><br><span class="line"></span><br><span class="line">Thanks to Bernard Aboba , Rasmus Brandt , Roni Even , Stefan Holmer ,</span><br><span class="line">Jonathan Lennox , and Magnus Westerlund for providing valuable</span><br><span class="line">feedback on earlier versions of this draft.</span><br></pre></td></tr></table></figure>



<p>剩下的我就不翻译了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/06/27/2020-06-27-STUN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/27/2020-06-27-STUN/" class="post-title-link" itemprop="url">RFC5389 - Session Traversal Utilities for NAT 翻译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-27 20:10:49" itemprop="dateCreated datePublished" datetime="2020-06-27T20:10:49+08:00">2020-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 16:22:18" itemprop="dateModified" datetime="2021-03-08T16:22:18+08:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">未分类</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>转载请注明作者及出处！</p>
<p>翻译中遇到的问题：</p>
<ul>
<li><input disabled="" type="checkbox"> 文章不能很好区分 indication 和 indication transaction</li>
<li><input disabled="" type="checkbox"> 存在不理解的内容以该格式进行标记 <font color="#D24C3D">?? 不理解的内容 ??</font></li>
</ul>
<p>还未检查的项目：</p>
<ul>
<li><input disabled="" type="checkbox"> 翻译的名词不会一个单词多个翻译。保证一致性</li>
<li><input disabled="" type="checkbox"> 句子结束的句号是否完整</li>
<li><input disabled="" type="checkbox"> 单词左右两边是否有空格</li>
<li><input disabled="" type="checkbox"> 大小写、拼写问题</li>
<li><input disabled="" type="checkbox"> 或、且，是否全都是左右两边加逗号</li>
</ul>
<p>译者注：</p>
<p>本翻译仅供参考，目的是让读者更好地理解 STUN 协议（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc5389/">RFC 5389</a>）。</p>
<p><u>我个人</u>对翻译的要求是逻辑严密准确，且文章<u>核心内容</u>与英文原版一致。</p>
<p>为了更方便读者理解，本翻译**<u>不保证</u>**部分措辞细节与英文原版一致。</p>
<p>为了保证文章的准确性，个别名词将不会进行翻译。</p>
<p>同样，为了保证文章的准确性，每句话的翻译都会附上英文原版供读者参考。</p>
<p>译者语文和英语的水平都不高，再次强调，本翻译仅供参考。</p>
<p>译者：Junyi</p>
<p>联系邮箱：me#junyi.pw (自行替换成 at 符号)</p>
<h1 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h1><p>STUN 全名叫 Session Traversal Utilities for NAT (STUN)</p>
<p>最新定义在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc5389/">RFC 5389</a></p>
<p>STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。</p>
<p>STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。</p>
<p>STUN 最初定义在 RFC 3489，有时我们也说这个最初版本为“经典STUN” （classic STUN）</p>
<p>在那时候其实已经是一个完整的 NAT 穿透问题的解决方案了，客户端可以去发现自己是否在 NAT 之后，确定其所在 NAT 的类型，发现其经过 NAT 转换后的 IP 地址和端口号，利用这个IP地址和端口号执行 SIP（Session Initiation Protocol）。</p>
<p><strong>听起来挺美好的哈，但是随着我们的应用部署，发现经典的 STUN 有时候根本不工作！</strong></p>
<ul>
<li><p>通过 STUN 获取到的 IP 地址和端口信息有时候可以让两个 peer 互通，有时候不行</p>
</li>
<li><p>在 peer 不互通时，经典 STUN 没有提供补救措施</p>
</li>
<li><p>在有些 NAT 内，经典 STUN 的算法是错误的</p>
</li>
<li><p>经典 STUN 存在安全漏洞（攻击者可以给 peer 提供错误的映射地址、拓扑、约束）。这个问题无法从根本解决，我们最新的协议也只能缓解这个问题。</p>
</li>
</ul>
<p>基于以上原因，RFC 3489 已经被废弃。</p>
<h2 id="3-操作概述-Overview-of-Operation"><a href="#3-操作概述-Overview-of-Operation" class="headerlink" title="3. 操作概述 Overview of Operation"></a>3. 操作概述 Overview of Operation</h2><blockquote>
<p>This section is descriptive only.</p>
</blockquote>
<p>本节仅作描述性用途。</p>
<blockquote>
<p>STUN is a client-server protocol.</p>
</blockquote>
<p>STUN 是一种 client-server 协议，换句话讲，运行 STUN 协议实现的主机既可以充当客户端也可以充当服务器。</p>
<blockquote>
<p>It supports two types of transactions.  </p>
</blockquote>
<p>STUN 支持两种类型的事务。</p>
<blockquote>
<p>One is a <u>request/response transaction</u> in which a client sends a request to a server, and the server returns a response.</p>
</blockquote>
<p>其中一种是<u>请求/响应型事务</u>。就是说客户端发送一个 request 给服务器，服务器返回给客户端一个 response 。</p>
<blockquote>
<p>The second is an <u>indication transaction</u> in which either agent – client or server – sends an indication that generates no response. </p>
</blockquote>
<p>另一种是<u>指示型事物</u>。客户端或服务器只是<font color="#D24C3D">??发送一个指示，并没有任何 response。??</font></p>
<blockquote>
<p>Both types of transactions include a <u>transaction ID</u>, which is a randomly selected <u>96-bit</u> number.</p>
</blockquote>
<p>上述的两种事务类型，都包含一个随机选择的<u>96位</u>的<u>事务ID</u>。</p>
<blockquote>
<p>For <u>request/response transactions,</u> this transaction ID allows the client to associate the response with the request that generated it; for <u>indications</u>, the transaction ID serves as a debugging aid.</p>
</blockquote>
<p>对于<u>请求/响应型事务</u>，<font color="#D24C3D">??事务ID允许客户端将其生成的<u>请求事务</u>与收到的<u>响应事务</u>相关联。??</font></p>
<p>对于<u>指示型事物</u>，事务ID充当调试工具的角色。</p>
<blockquote>
<p>All STUN messages start with a fixed header that includes a <u>method</u>, a <u>class</u>, and the <u>transaction ID</u>.</p>
</blockquote>
<p>所有的 STUN 消息都以一个固定的头部开始。这个头部包含<u>方法</u>、<u>类</u>、<u>事物ID</u>[^1]</p>
<ul>
<li><blockquote>
<p>The <u>method</u> indicates which of the various <u>requests</u> or <u>indications</u> this is; this specification defines just one method, Binding, but other methods are expected to be defined in other documents.</p>
</blockquote>
<p><u>方法</u>表示这是哪种<u>请求</u>，或，这是哪种<u>指示</u>。在当前您阅读的这个 RFC 规范里，我们只规定了一种方法：Binding。（其他的方法有望在其他文档中定义）</p>
</li>
<li><blockquote>
<p>The <u>class</u> indicates whether this is a <u>request</u>, a <u>success response</u>, an <u>error response</u>, or an <u>indication</u>. </p>
</blockquote>
<p><u>类</u>表示这是一个<u>请求</u>、<u>成功的响应</u>、<u>错误的响应</u>还是一个<u>指示</u>。</p>
</li>
</ul>
<blockquote>
<p>Following the fixed header comes zero or more attributes, which are <u>Type-Length-Value</u> extensions that convey additional information for the specific message.</p>
</blockquote>
<p>紧跟在固定头部后面的是 0 个或多个 <u>Type-Length-Value</u> 扩展属性。不用细说，相信你也明白这个扩展属性的用途是为了传递附加信息。</p>
<hr>
<blockquote>
<p>This document defines a single <u>method</u> called Binding. The Binding method can be used either in request/response transactions or in indication transactions. </p>
</blockquote>
<p>这份文档只定义了 Binding 这个<u>方法</u>，这个方法既可以用在<u>请求/响应型事务</u>，又可以用在<u>指示型事物</u>。</p>
<blockquote>
<p>When used in <u>request/response transactions</u>, the Binding <u>method</u> can be used to determine the particular “binding” a NAT has allocated to a STUN client. When used in either <u>request/ response</u> <strong>or</strong> in <u>indication transactions</u>, the Binding <u>method</u> can also be used to keep these “bindings” alive.</p>
</blockquote>
<p>当在<u>请求/响应型事务</u>中使用 Binding <u>方法</u>时，它可以用来确定一个 NAT 分配给 STUN 客户端的特定 “绑定”。</p>
<p>当在<u>请求/响应型事务</u><strong>或</strong><u>指示型事物</u>中使用 Binding <u>方法</u>时，这个方法还可以用来维持这些特定 “绑定” 是活动的。</p>
<hr>
<blockquote>
<p>In the Binding <u>request/response transaction</u>, a <u>Binding request</u> is sent from a STUN client to a STUN server. </p>
</blockquote>
<p>在使用 Binding 方法的<u>请求/响应型事务</u>中，一条 <u>Binding 请求</u> 会从 STUN 客户端发往 STUN 服务器。</p>
<blockquote>
<p>When the <u>Binding request</u> arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server (in Figure 1, there were two such NATs).</p>
</blockquote>
<p>一条 <u>Binding 请求</u> 到达 STUN 服务器的过程里，可能会穿越 1 个或多个 NAT 设备。（在 Figure 1 中穿越了两个 NAT 设备）</p>
<blockquote>
<p>As the <u>Binding request</u> message passes through a NAT, the NAT will modify the <u>source transport address</u> (that is, the source IP address and the source port) of the packet. As a result, the <u>source transport address</u> of the request received by the server will be the <u>public IP address and port</u> created <strong>by the NAT closest to the server</strong>. This is called a <u>reflexive transport address</u>.</p>
</blockquote>
<p>在一个 <u>Bingding 请求</u> 数据包经过 NAT 的时候，NAT 会修改该数据包的<u>来源地址和端口</u>。</p>
<p>对于服务器来说，接收到的这份数据包的<u>来源地址和端口</u>其实是<strong>离服务器最近的 NAT的<u>公网 IP 地址和端口</u></strong> 。</p>
<p>这叫做 <u>reflexive transport address</u>。</p>
<p><font color="#D24C3D">??这个请求数据包的source地址叫做 reflexive transport address？??</font></p>
<blockquote>
<p>The STUN server copies that <u>source transport address</u> into an <u>XOR-MAPPED-ADDRESS</u> attribute in the STUN Binding response and sends the <u>Binding response</u> back to the STUN client. As this packet passes back through a NAT, the NAT will modify the <u><strong>destination</strong> transport address</u> in the IP header, but the transport address in the XOR-MAPPED-ADDRESS attribute within the body of the STUN response will remain untouched.</p>
</blockquote>
<p>接着，STUN 服务器会产生一个 <u>Binding 响应</u>，然后复制收到数据包的 <u>来源地址和端口</u> 到 <u>Binding 响应</u> 里的一个叫做 <u>XOR-MAPPED-ADDRESS</u> 的属性中，然后将 <u>Binding 响应</u> 发回 STUN 客户端。</p>
<p>这个响应数据包也会经过 NAT，NAT 会修改该数据包的<u><strong>目标</strong>地址和端口</u>。</p>
<p>注意，NAT 只会修改 IP 报头的地址和端口（来源或目标），不会修改 XOR-MAPPED-ADDRESS 中的内容。也就是说，NAT 只修改头部，不修改 Payload。</p>
<blockquote>
<p>In this way, the client can learn its reflexive transport address allocated by the <u>outermost NAT</u> with respect to the STUN server.</p>
</blockquote>
<p>通过这种方式，客户端可以了解到自己 <u>最外部 NAT</u> 给自己分配的的 reflexive transport address。</p>
<p>这里说的最外部，指的是相对于 STUN server 的最外部。套娃你懂吧，STUN server 有可能在一个非常大的子网里，这个时候客户端了解到的只是离 STUN 最近的那个 NAT 反射回的地址。</p>
<hr>
<blockquote>
<p>In some usages, STUN must be multiplexed with other protocols (e.g., [MMUSIC-ICE], [SIP-OUTBOUND]). In these usages, there must be a way to inspect a packet and determine if it is a STUN packet or not. </p>
</blockquote>
<p>在某些情况下， STUN 必须与其他协议复用（比如 MMUSIC-ICE, SIP-OUTBOUND）。在这些情况下，必须有一种方式来检测数据包是否为 STUN 协议类型。</p>
<blockquote>
<p>STUN provides three fields in the STUN header with fixed values that can be used for this purpose. If this is not sufficient, then STUN packets can also contain a <u>FINGERPRINT value</u>, which can further be used to distinguish the packets.</p>
</blockquote>
<p>STUN 在头部提供了三个字段用于其特殊情况下检测协议类型的目的。如果这三个字段仍然不够完成检测工作，那么 STUN 数据包中还可以通过包含 <u>FINGERPRINT 值</u> 来进一步区分数据包的协议类型。</p>
<hr>
<blockquote>
<p>STUN defines a set of optional procedures that a usage can decide to use, called <u>mechanisms</u>. These <u>mechanisms</u> include DNS discovery, a redirection technique to an <u>alternate server</u>, a fingerprint attribute for <u>demultiplexing</u>, and <u>two authentication</u> and <u>message-integrity exchanges</u>. The authentication mechanisms revolve around the use of a username, password, and message-integrity value. <u>Two authentication mechanisms</u>, the <u>long-term credential mechanism</u> and the <u>short-term credential mechanism</u>, are defined in this specification. </p>
</blockquote>
<p>STUN 定义了一系列的可选操作，称为<u>机制</u>。这些<u>机制</u>包含了：</p>
<ul>
<li><p><u>DNS发现</u>机制</p>
</li>
<li><p><u>备选服务器</u>的重定向机制</p>
</li>
<li><p><u>解多路复用</u>[^2]的 fingerprint 属性机制</p>
</li>
<li><p><u>双授权</u>机制</p>
</li>
<li><p><u>信息完整性交换</u>机制</p>
</li>
</ul>
<p>其中，<u>双授权机制</u>，在本手册中定义为<u>长期凭据机制</u>和<u>短期凭据机制</u>。</p>
<blockquote>
<p>Each usage specifies the mechanisms allowed with that usage.</p>
</blockquote>
<p>不同的使用场景决定了这些机制的具体用法。换句话讲，不同的使用场景被允许使用的机制是不同的。</p>
<hr>
<blockquote>
<p>In the long-term credential mechanism, the client and server share a pre-provisioned username and password and perform a <u>digest challenge / response exchange</u> inspired by (but differing in details) to the one defined for HTTP [RFC2617].</p>
</blockquote>
<p>在<u>长期凭据机制</u>里，客户端和服务器共享一个预先分配好的用户名和密码，然后执行 <u>digest challenge / response exchange</u>。</p>
<p>这个<u>长期凭据机制</u>受到 RFC 2617 的启发，但是具体细节上与 RFC 2617 不同。</p>
<blockquote>
<p>In the short-term credential mechanism, the client and the server exchange a username and password through some <u>out-of-band method</u> prior to the <u>STUN exchange</u>. For example, in the ICE usage [MMUSIC-ICE] the two endpoints use <u>out-of-band signaling</u> to exchange a username and password. These are used to <u>integrity protect</u> and <u>authenticate the request and response</u>. There is no challenge or nonce used.</p>
</blockquote>
<p>在<u>短期凭据机制</u>里，客户端和服务器在 <u>STUN 交换</u> 之前，通过一些 <u>out-of-band 的方式</u>[^3]来交换用户名和密码。举个例子，在 ICE中，两个端点使用 <u>out-of-band 信令</u> 来交换用户名和密码。它们被用来<u>保证消息的完整性</u>和<u>对请求和响应进行授权</u>。没有使用 challenge 或 nonce[^4]。</p>
<h2 id="4-术语-Terminology"><a href="#4-术语-Terminology" class="headerlink" title="4. 术语 Terminology"></a>4. 术语 Terminology</h2><blockquote>
<p>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in BCP 14, RFC 2119 [RFC2119] and indicate requirement levels for compliant STUN implementations.</p>
</blockquote>
<p>在这份文档中，“**<u><em>必须</em></u><strong>”，“</strong><u><em>必须不</em></u><strong>”，“</strong><u><em>必需要</em></u><strong>”，“</strong><u><em>应当</em></u><strong>”，“</strong><u><em>不应当</em></u><strong>”，“</strong><u><em>最好</em></u><strong>”，“</strong><u><em>最好不</em></u><strong>”，“</strong><u><em>建议</em></u><strong>”，“</strong><u><em>或许</em></u><strong>”，“</strong><u><em>可选</em></u>**”，将按照 BCP 14，RFC 2119 来解释说明 STUN 所需的的实现级别。</p>
<p><font color="red">因为中英文单词差异，所以在本翻译中，涉及到的上述词汇都会用**<u><em>粗体倾斜下划线</em></u>**来表示。</font></p>
<h2 id="5-定义-Definitions"><a href="#5-定义-Definitions" class="headerlink" title="5. 定义 Definitions"></a>5. 定义 Definitions</h2><blockquote>
<p>STUN Agent: A STUN agent is an entity that implements the STUN protocol. The entity can be either a STUN client or a STUN server.</p>
</blockquote>
<p><strong>STUN 代理</strong>：一个实现了 STUN 协议的实体被称为 STUN 代理。（既可以为客户端又可以为服务器）</p>
<blockquote>
<p>STUN Client: A STUN client is an entity that <u>sends STUN requests</u> and <u>receives STUN responses</u>. A STUN client can also send <u>indications</u>. In this specification, the terms <u>STUN client</u> and <u>client</u> are synonymous.</p>
</blockquote>
<p><strong>STUN 客户端</strong>：一个可以<u>发送 STUN 请求</u>，且，<u>接受 STUN 响应</u>的实体，被称为 STUN 客户端。STUN 客户端也可以发送<u>指示</u>[^5]。您可以理解 <u>STUN 客户端</u>和<u>客户端</u>是同义词。</p>
<blockquote>
<p>STUN Server: A STUN server is an entity that receives STUN requests and sends STUN responses. A STUN server can also send indications. In this specification, the terms <u>STUN server</u> and <u>server</u> are synonymous.</p>
</blockquote>
<p><strong>STUN 服务器</strong>：一个可以<u>接收 STUN 请求</u>，且，<u>发送 STUN 响应</u>的实体，被称为 STUN 服务器。STUN 服务器也可以发送<u>指示</u>[^5]。您可以理解 <u>STUN 服务器</u>和<u>服务器</u>是同义词。</p>
<blockquote>
<p>Transport Address: The combination of an <u>IP address</u> and port number (such as a UDP or TCP port number).</p>
</blockquote>
<p><strong>传输地址</strong>：<u>IP地址</u>和<u>端口</u>的组合被称为传输地址。</p>
<blockquote>
<p>Reflexive Transport Address: A transport address learned by a client that identifies that client as seen by another host on an IP network, typically a STUN server. When there is an intervening NAT between the client and the other host, the reflexive transport address represents the mapped address allocated to the client on <u>the public side of the NAT</u>. Reflexive transport addresses are learned from the mapped address attribute (<u>MAPPED-ADDRESS</u> or <u>XOR-MAPPED-ADDRESS</u>) in STUN responses.</p>
</blockquote>
<p><strong>反射性传输地址</strong>：一个客户端从“其他主机”那里了解到的自己的传输地址。一般这个“其他主机”指的是 STUN 服务器。当 NAT 干预在客户端与“其他主机”之间时，反射性传输地址代表了这个客户端在 <u>NAT 的公共区域那一侧</u>被分配到的传输地址。这个反射性传输地址被放在 STUN 响应的 <u>MAPPED-ADDRESS</u> 或 <u>XOR-MAPPED-ADDRESS</u> 里。</p>
<p>讲人话就是，客户端拿到的公网IP地址和端口号的组合就叫反射性传输地址。（不严谨，要想严谨还是得看上面的定义）</p>
<blockquote>
<p>Mapped Address: Same meaning as reflexive address. This term is retained only for historic reasons and due to the naming of the MAPPED-ADDRESS and XOR-MAPPED-ADDRESS attributes.</p>
</blockquote>
<p><strong>映射地址</strong>：跟反射性传输地址一样。这是个因为历史原因而保留下来的词。</p>
<blockquote>
<p>Long-Term Credential: A username and associated password that represent a shared secret between client and server. Long-term credentials are generally granted to the client when a subscriber enrolls in a service and persist until the subscriber leaves the service or explicitly changes the credential.</p>
</blockquote>
<p><strong>长期凭据</strong>：客户端和服务器共享的用户名密码。长期凭据通常在订阅者订阅一个服务时授予给客户端，并且一直持续到订阅者退出服务或显式更改凭据。</p>
<blockquote>
<p>Long-Term Password: The password from a long-term credential.</p>
</blockquote>
<p><strong>长期密码</strong>：长期凭据所使用的密码。</p>
<blockquote>
<p>Short-Term Credential: A <strong>temporary</strong> username and associated password that represent a shared secret between client and server. Short-term credentials are obtained through some kind of protocol mechanism between the client and server, preceding the <u>STUN exchange</u>. A short-term credential has an explicit temporal scope, which may be based on a specific amount of time (such as 5 minutes) or on an event (such as termination of a SIP dialog).</p>
<p>The specific scope of a short-term credential is defined by the application usage.</p>
</blockquote>
<p><strong>短期凭据</strong>：客户端和服务器共享的<strong>临时的</strong>用户名密码。短期凭据一般是在 <u>STUN 交换</u>之前，通过某种协议机制获得的。短期凭据有一个显式的时间范围，可能基于时间量（比如 5 分钟），或，基于事件（比如 SIP 对话的终止）。</p>
<p>具体的时间范围，由具体的应用程序使用场景决定。</p>
<blockquote>
<p>Short-Term Password: The password component of a short-term credential.</p>
</blockquote>
<p><strong>短期密码</strong>：短期凭据所使用的密码。</p>
<blockquote>
<p>STUN Indication: A STUN message that does not receive a response.</p>
</blockquote>
<p><strong>STUN 指示</strong>：一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p>
<blockquote>
<p>Attribute: The STUN term for a Type-Length-Value (TLV) object that can be added to a STUN message. Attributes are divided into two types: <u>comprehension-required</u> and <u>comprehension-optiona</u>l. <u>STUN agents</u> can safely ignore <u>comprehension-optional</u> attributes they don’t understand, but cannot successfully process a message if it contains comprehension-required attributes that are not understood.</p>
</blockquote>
<p><strong>属性</strong>：一个 TLV 对象可以被附加在 STUN 消息里。一共有两种类型的属性：<u>必须要理解的</u>和<u>可选理解的</u>。<u>STUN 代理</u> 可以安全的忽略那些它们无法理解的、<u>可选理解的</u>属性，但是无法成功处理它们无法理解的、<u>必须要理解的</u>属性。</p>
<blockquote>
<p>RTO: Retransmission TimeOut, which defines the initial period of time between transmission of a request and the first retransmit of that request.</p>
</blockquote>
<p><strong>RTO</strong>：重传超时。也就是从请求传输到第一次重新传输之间的时间。</p>
<h2 id="6-STUN-消息结构-STUN-Message-Structure"><a href="#6-STUN-消息结构-STUN-Message-Structure" class="headerlink" title="6. STUN 消息结构 STUN Message Structure"></a>6. STUN 消息结构 STUN Message Structure</h2><blockquote>
<p><u>STUN messages</u> are encoded in binary using network-oriented format (most significant byte or octet first, also commonly known as big-endian). The transmission order is described in detail in Appendix B of RFC 791 [RFC0791]. Unless otherwise noted, numeric constants are in decimal (base 10).</p>
</blockquote>
<p><u>STUN 消息</u>使用 MSB 的二进制格式编码（big-endian）。传输顺序在 RFC 791 的 Appendix B 中有详细描述。除了特别注明之外，数字常量都以 10 进制表示。</p>
<blockquote>
<p>All <u>STUN messages</u> MUST start with a 20-byte header followed by zero or more <strong>Attributes</strong>. The STUN header contains a <u>STUN message type</u>, <u>magic cookie</u>, <u>transaction ID</u>, and <u>message length</u>.</p>
</blockquote>
<p>所有的 <u>STUN 消息</u> <strong><em><u>必须</u></em></strong> 以 20-byte 长度的头部开始，紧跟着 0 个 或 多个<strong>属性</strong>。STUN 头部包含了 <u>STUN 消息类型</u>、<u>magic cookie</u>、<u>事务ID</u>、<u>消息长度</u>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|0 0|     STUN Message Type    |         Message Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Magic Cookie                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">|                     Transaction ID (96 bits)                  |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">                  Figure 2: Format of STUN Message Header</span><br></pre></td></tr></table></figure>



<blockquote>
<p>The most significant 2 bits of every <u>STUN message</u> MUST be zeroes. This can be used to differentiate <u>STUN packet</u>s from other protocols when STUN is multiplexed with other protocols on the same port.</p>
</blockquote>
<p>每条 <u>STUN 消息</u> 的最高 2 bit <strong><u><em>必须</em></u></strong> 为零。这可以在 STUN 与其他协议在同一端口复用时，区分 <u>STUN 数据包</u>。</p>
<blockquote>
<p>The <u>message type</u> defines the message class (<u>request</u>, <u>success response</u>, <u>failure response</u>, or <u>indication</u>) and the message <u>method</u> (the primary function) of the STUN message. Although there are four message classes, there are only two types of transactions in STUN: <u>request/response transactions</u> (which consist of a request message and a response message) and <u>indication transactions</u> (which consist of a single <strong><u>indication</u></strong> message). Response classes are split into error and success responses to aid in quickly processing the STUN message.</p>
</blockquote>
<p><u>STUN 消息类型</u>定义了消息所属的类（<u>请求</u>，<u>成功的响应</u>，<u>失败的响应</u>，<u>指示</u>），和，一条 STUN 消息的<u>方法（主要功能）</u>[^6]</p>
<p>尽管有四种消息所属的类，但在 STUN 中只有两种事务类型：<u>请求/响应型事务</u>（包含请求消息和响应消息），和，<u>指示型事务</u>（包含单独的一条<u><strong>STUN 指示</strong></u>[^7]消息）。响应类被划分为<u>失败的响应</u>和<u>成功的响应</u>，目的是帮助快速处理 STUN 消息。</p>
<p>更直观一点来讲：</p>
<ul>
<li>Transaction Type：请求/响应型事务<ul>
<li>Message Type：请求</li>
<li>Message Type：成功的响应</li>
<li>Message Type：失败的响应</li>
</ul>
</li>
<li>Transaction Type：指示型事务<ul>
<li>Message Type：指示</li>
</ul>
</li>
</ul>
<blockquote>
<p>The message type field is decomposed further into the following structure:</p>
</blockquote>
<p><strong>STUN Message Type</strong> 字段被分解成以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0                 1</span><br><span class="line"> 2  3  4 5 6 7 8 9 0 1 2 3 4 5 </span><br><span class="line">+--+--+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|M |M |M|M|M|C|M|M|M|C|M|M|M|M|</span><br><span class="line">|11|10|9|8|7|1|6|5|4|0|3|2|1|0|</span><br><span class="line">+--+--+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">Figure 3: Format of STUN Message Type Field</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Here the bits in the message type field are shown as most significant (M11) through least significant (M0). M11 through M0 represent a 12-bit encoding of the <u>method</u>. C1 and C0 represent a 2-bit encoding of the <u>class</u>. A class of 0b00 is a <u>request</u>, a class of 0b01 is an <u>indication</u>, a class of 0b10 is a <u>success response</u>, and a class of 0b11 is an <u>error response</u>. This specification defines a single method, Binding. <strong>The method and class are orthogonal, so that for each method, a <u>request</u>, <u>success response</u>, <u>error response</u>, and <u>indication</u> are possible for that method.</strong> Extensions defining new methods MUST indicate which <u>classes</u> are permitted for that method.</p>
</blockquote>
<p>Message Type 字段从最高有效位（M11）开始到最低有效位（M0）结束。M11 到 M0 一共是 12-bit，这12个bit编码了<u>方法</u>。 C1 和 C- 表示<u>类</u>，由2个bit组成。0b00 表示一个<u>请求</u>，0b01 表示一个<u>指示</u>，0b10 表示一个<u>成功的响应</u>，0b11 表示一个<u>失败的响应</u>。</p>
<p>当前文档里定义了一个单独的方法，Bingding。方法和类是<font color="red">??正交??</font>的关系，<strong>因此对于每个方法，都要有<u>请求</u>、<u>指示</u>、<u>成功的响应</u>、<u>失败的响应</u>。</strong></p>
<p>定义新的扩展方法时 <strong><u><em>必须</em></u></strong> 指明允许哪些<u>类</u></p>
<blockquote>
<p>For example, a Binding <u>request</u> has class=0b00 (request) and method=0b000000000001 (Binding) and is encoded into the first 16 bits as 0x0001. A Binding response has class=0b10 (success response) and method=0b000000000001, and is encoded into the first 16 bits as 0x0101.</p>
</blockquote>
<p>例如，一个 Binding 方法的<u>请求</u>的类的编码为 0b00，方法号为 0b000000000001。前16个bit的十六进制编码为 0x0001。Binding 方法的响应的类的编码为 0b10，方法号同样为 0b000000000001，前16个bit的十六进制编码为 0x0101。</p>
<p>译者补充：注意，您可能会好奇，类的编码长度为2bit，方法编码长度为12bit，加起来一共14bit，为什么这里说前16bit呢？原因是，这里说的前16个bit，指的是 <u>STUN 消息</u>（或着说 STUN 数据包）的前16bit，对于一个 STUN 消息，最高位的 2bit 是被保留的，还记得吗？</p>
<blockquote>
<p>Note: This unfortunate encoding is due to assignment of values in [RFC3489] that did not consider encoding Indications, Success, and Errors using bit fields.</p>
</blockquote>
<p>请注意：</p>
<p>The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order. In RFC 3489 [RFC3489], this field was part of the transaction ID; placing the magic cookie in this location allows a server to detect if the client will understand certain attributes that were added in this revised specification. In addition, it aids in distinguishing STUN packets from packets of other protocols when STUN is multiplexed with those other protocols on the same port.</p>
<p>[^1]: 还记得吗，<u>事务ID</u>是一个随机选择的 96位 的数字<br>[^2]: 解多路复用就是与多路复用的作用相反的一个过程<br>[^3]: In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_networking">computer networking</a>, <strong>out-of-band data</strong> is the data transferred through a stream that is independent from the main <em>in-band</em> data stream.<br>[^4]: 在資訊安全中，Nonce是一個在加密通訊只能使用一次的數字。在認證協定中，它往往是一個隨機或偽隨機數，以避免重送攻擊。<br>[^5]: indicatino 在 indication transaction 中被发送。 <u>指示</u> 在 <u>指示型事务</u> 中被发送<br>[^6]: The <u>method</u> indicates which of the various <u>requests</u> or <u>indications</u> this is. <u>方法</u>表示这是哪种<u>请求</u>，或，这是哪种<u>指示</u>。<br>[^7]: 一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/06/26/2020-06-26-P2P%E6%8A%80%E6%9C%AF%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/26/2020-06-26-P2P%E6%8A%80%E6%9C%AF%E4%B8%80/" class="post-title-link" itemprop="url">P2P 技术 （一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-26 13:06:35" itemprop="dateCreated datePublished" datetime="2020-06-26T13:06:35+08:00">2020-06-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 16:01:08" itemprop="dateModified" datetime="2021-03-08T16:01:08+08:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/P2P-%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">P2P 技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络地址转换-NAT-Network-Address-Translation"><a href="#网络地址转换-NAT-Network-Address-Translation" class="headerlink" title="网络地址转换 NAT (Network Address Translation)"></a>网络地址转换 NAT (Network Address Translation)</h1><h2 id="基本网络地址转换-Basic-NAT"><a href="#基本网络地址转换-Basic-NAT" class="headerlink" title="基本网络地址转换 Basic NAT"></a><strong>基本网络地址转换 Basic NAT</strong></h2><p>简单来讲，就是直接把内部IP翻译成外部IP，这种转换技术受限于对外地址的数量，是IP到IP的转换（端口不换）</p>
<p>需要了解的名词有：</p>
<ul>
<li>SNAT：源地址转换</li>
<li>DNAT：目标地址转换</li>
</ul>
<p>以只有一个对外地址举例，如果 ClientA 和 ClientB 同时访问同一个 Web Server，那么当 NAT Gatway 收到这个 Web Server 响应包的时候，就无法判断将数据包转发给哪台客户机。</p>
<p>于是就有了我们接下来要介绍的NAPT技术</p>
<h2 id="网络地址端口转换-NAPT"><a href="#网络地址端口转换-NAPT" class="headerlink" title="网络地址端口转换 NAPT"></a><strong>网络地址端口转换 NAPT</strong></h2><p>先明确几个概念：</p>
<p>内网主机拥有的网络地址：<code>(LocalIP:LocalPort)</code></p>
<p>经由NAT转换后的网络地址：<code>(PublicIP:PublicPort)</code></p>
<p>外网主机拥有的网络地址：<code>(RemoteIP:RemotePort)</code></p>
<p>对<code>源端口</code>和<code>目标端口</code>同时进行转换。这样就可以让<code>一个公网IP</code>满足<code>多个后端主机</code>同时访问外部网络。比如家庭宽带。</p>
<p>这项技术最为常见，它检测并修改出入数据包的<u>IP地址</u>和<u>端口号</u>，从而允许多个内网主机共享同一个公网IP地址</p>
<p>NAT 分为 <code>锥形NAT</code> 和 <code>对称型NAT</code></p>
<h1 id="锥形NAT"><a href="#锥形NAT" class="headerlink" title="锥形NAT"></a>锥形NAT</h1><p><strong>同一个内部主机的地址和端口，无论目的地址是否相同，NAT都将它转换成同一个外部地址和端口。</strong></p>
<p>192.168.1.2:8000 访问 Baidu.com:80 和 google.com:80 时，经由 NAT 转换，内部的 192.168.1.2:8000 都会被转化成 1.2.3.4:5000，baidu看到的是 5000 端口，谷歌看到的也是</p>
<p>192.168.1.2:<strong>8001</strong> 访问 baidu.com:80 和 google.com:80 时，经由 NAT 转换，内部的 192.168.1.2:8001 都会变成 1.2.3.4:<strong>5001</strong>，baidu看到的是 <strong>5001</strong>端口，google 看到的也是。</p>
<p>懂了吗，这就是锥形的由来</p>
<h2 id="全锥形NAT-（Full-Cone-NAT）"><a href="#全锥形NAT-（Full-Cone-NAT）" class="headerlink" title="全锥形NAT （Full Cone NAT）"></a>全锥形NAT （Full Cone NAT）</h2><p>内向外：<code>(特定本地IP:特定本地端口)</code> –&gt;<code>(固定映射IP:固定映射端口)</code> –&gt; <code>(特定远端IP:特定远端端口)</code></p>
<p>建立Full Cone NAT转换后</p>
<p>外向内：<code>(特定本地IP:特定本地端口)</code> &lt;– <code>(固定映射IP:固定映射端口)</code> &lt;– <code>(任意远端IP:任意端口)</code></p>
<p>当内部主机向外发送请求时，NAT网关会打开一个端口创建一个公网映射，形成一个IP端口元组，然后会将传入这个端口的数据全部转发给内部主机。<strong>一旦映射建立，那么任意一台主机，只要给映射出来的公网IP和端口发送数据，就可以直接到达后端服务：</strong></p>
<p>也就是，内部主机以相同的 (LocalIP:LocalPort) 对 2 个不同的 (RemoteIP:RemotePort) 发送 UDP 报文时，NAT 会为内部主机只分配一个 (PublicIP:PublicPort)，<strong>任意一台主机都可以给 (PublicIP:PublicPort) 发送数据。</strong></p>
<h2 id="地址限制锥形NAT-（Address-Restricted-Cone-NAT）"><a href="#地址限制锥形NAT-（Address-Restricted-Cone-NAT）" class="headerlink" title="地址限制锥形NAT （Address Restricted Cone NAT）"></a>地址限制锥形NAT （Address Restricted Cone NAT）</h2><p>远端 IP 地址受限，远端端口无所谓</p>
<p>内向外：<code>(特定本地IP:特定本地端口)</code> –&gt;<code>(固定映射IP:固定映射端口)</code> –&gt; <code>(特定远端IP:特定远端端口)</code></p>
<p>建立Address Restricted Cone NAT转换后</p>
<p>外向内：<code>(特定本地IP:特定本地端口)</code> &lt;– <code>(固定映射IP:固定映射端口)</code> &lt;– <code>(特定远端IP:任意端口)</code></p>
<p>（注意这里变成了 <strong>任意</strong>端口）</p>
<p>我更喜欢它的英文形式，中文翻译的很不恰当。英文叫<code>地址受限的锥形NAT</code>。当内部主机向外发送请求时，NAT网关会打开一个端口创建一个公网映射，<strong>同时记录外网的IP地址</strong>。一旦映射建立，<strong>只有被记录的IP地址给映射出来的公网IP和端口发送数据，才可以到达后端服务，其他IP地址发送给NAT网关的，将会被丢弃。</strong></p>
<p>也就是，内部主机以相同的 (LocalIP:LocalPort) 对 2 个不同的 (RemoteIP:RemotePort) 发送 UDP 报文时，NAT 会为内部主机只分配一个 (PublicIP:PublicPort)，同时，也只有这 2 个 RemoteIP 可以给 (PublicIP: PublicPort) 发送数据（因为先由内向外发过），这两个 RemoteIP 的 RemotePort 可以是任意的</p>
<h2 id="端口限制锥形NAT（Port-Restricted-Cone-NAT）"><a href="#端口限制锥形NAT（Port-Restricted-Cone-NAT）" class="headerlink" title="端口限制锥形NAT（Port Restricted Cone NAT）"></a>端口限制锥形NAT（Port Restricted Cone NAT）</h2><p>远端 IP 地址和端口都受限，且只有内部主机向外发送过消息才可以建立。</p>
<p>一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</p>
<p>内向外：<code>(特定本地IP:特定本地端口)</code> –&gt;<code>(固定映射IP:固定映射端口)</code> –&gt; <code>(特定远端IP:特定远端端口)</code></p>
<p>建立Port Restricted Cone NAT转换后</p>
<p>外向内：<code>(特定本地IP:特定本地端口)</code> &lt;– <code>(固定映射IP:固定映射端口)</code> &lt;– <code>(特定远端IP:特定端口)</code></p>
<p>（注意这里变成了 <strong>特定</strong>端口）</p>
<p>这种模式同时记录<u>内部主机的IP和端口</u>和<u>外部主机的IP和端口</u>，也就是形成了一种绑定关系。</p>
<p>与 Address Restricted Cone NAT 的区别是， Address Restricted Cone NAT 记录的只有外网主机的IP，不记录端口，那个外网主机的随便一个端口给内网主机发送数据都可以。</p>
<p>Port Restricted Cone NAT 是记录外网主机的IP和端口，<strong>只有 (内网IP, 内网端口) 和 (外网IP,外网端口) 这两个条件同时满足，数据才会转发给内网主机。</strong>而且以后给外部任何主机发送数据，都会用之前转换的(PublicIP:PublicPort)给外部主机发送数据。</p>
<p>也就是，内部主机以相同的 (LocalIP:LocalPort) 对 2 个不同的 (RemoteIP:RemotePort) 发送 UDP 报文时，NAT 会为内部主机只分配一个 (PublicIP:PublicPort)，同时，也只有这 2 个 (RemoteIP:ReportPort) 可以给 (PublicIP: PublicPort) 发送数据（因为先由内向外发过）</p>
<h1 id="对称形-NAT（Symmetric-NAT）"><a href="#对称形-NAT（Symmetric-NAT）" class="headerlink" title="对称形 NAT（Symmetric NAT）"></a>对称形 NAT（Symmetric NAT）</h1><p>连接不同的外部目标，NAT打开的端口不同。是一种「一对一映射关系」。</p>
<p>换句话讲，不同的 <code>(iAddr:port, eAddr:port)</code> 组合，NAT 网关会产生不同的链路。</p>
<p>看起来也就是对称的了。<code>（本地地址:端口，目标地址:端口）</code></p>
<p>比如 <u>localA</u>:8000 经过一台拥有 <u>global</u> 的一台对称NAT的Gateway，访问 <u>baidu</u>:80 和 <u>google</u>:80，</p>
<p>baidu 看到的可能是来自 <u>global</u>:5003 的请求，google 看到的可能是来自 <u>global</u>:5010 的请求。</p>
<p>打个比方，当内部主机以相同的 <code>(LocalIP:LocalPort)</code> 对 2 个不同的 <code>(RemoteIP:RemotePort)</code> 发送UDP报文时，此时 NAT 将会为内部主机分配<strong>两个不同的</strong> <code>(PublicIP:PublicPort)</code>，并且建立起<strong>两个不同的内、外部Tuple转换关系</strong>。</p>
<h1 id="Symmetric-和-Port-Restricted-的区别"><a href="#Symmetric-和-Port-Restricted-的区别" class="headerlink" title="Symmetric 和 Port Restricted 的区别"></a>Symmetric 和 Port Restricted 的区别</h1><p>Port Restricted: </p>
<ul>
<li>一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
</ul>
<p><img data-src="/2020-06-26-P2P%E6%8A%80%E6%9C%AF%E4%B8%80/800px-Port_Restricted_Cone_NAT.svg.png"></p>
<p>Symmetric:</p>
<ul>
<li>每一个来自相同内部 IP 与端口，到一个特定目的地 IP 和端口的请求，都映射到一个独特的外部 IP 和端口。</li>
</ul>
<p><img data-src="/2020-06-26-P2P%E6%8A%80%E6%9C%AF%E4%B8%80/800px-Symmetric_NAT.svg.png"></p>
<h1 id="引用-Reference"><a href="#引用-Reference" class="headerlink" title="引用 Reference"></a>引用 Reference</h1><p><a target="_blank" rel="noopener" href="https://evilpan.com/2015/10/31/p2p-over-middle-box/">[1] P2P 通信原理与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136794983">[2] 网络之 NAT 和 N2N VPN</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/my_life/articles/11018457.html">[3] NAT 的四种类型及类型检测 2【很好】</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">[4]网络地址转换 - Wikipedia</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/04/11/2020-04-11-%E6%88%91%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/11/2020-04-11-%E6%88%91%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/" class="post-title-link" itemprop="url">我的开发环境是怎样的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-11 00:00:01" itemprop="dateCreated datePublished" datetime="2020-04-11T00:00:01+08:00">2020-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 14:23:15" itemprop="dateModified" datetime="2021-03-08T14:23:15+08:00">2021-03-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>电脑用了这么久，我也有了自己的一套开发工具和流程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/11/2020-04-11-%E6%88%91%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/03/07/tvm/2020-03-07-tvm-android-rpc-%E8%B8%A9%E5%9D%91%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/07/tvm/2020-03-07-tvm-android-rpc-%E8%B8%A9%E5%9D%91%E8%AE%B0/" class="post-title-link" itemprop="url">TVM Andoird RPC 踩坑记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-07 02:19:35" itemprop="dateCreated datePublished" datetime="2020-03-07T02:19:35+08:00">2020-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-28 17:46:41" itemprop="dateModified" datetime="2021-02-28T17:46:41+08:00">2021-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TVM-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">TVM 系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><p>系统环境：Ubuntu 18.04 LTS</p>
<p>解决方法：卸载 OpenJDK-11，安装 OpenJDK-8</p>
<p>备注说明：VMWare 无法正常使用独立显卡，深度学习请不要在虚拟机里进行，否则只能利用 CPU 进行学习。</p>
<p>当编译 android_rpc 时，你<font color="red"><strong><u>必须</u></strong></font>在 <code>jni/config.ml</code> 里指定 <code>libOpenCL.so</code>，然后在 GitHub 下载 CL-headers。</p>
<p>When you compile android_rpc, you <strong>HAVE TO</strong> specify the libOpenCL.so in jni/config.mk, which pulled from your Android phone. Then, download CL-headers from github!</p>
<p><strong>READ THE OFFICIAL INSTRUCTIONS CAREFULLY!!</strong></p>
<p><strong>仔细阅读官方指南！！</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/07/tvm/2020-03-07-tvm-android-rpc-%E8%B8%A9%E5%9D%91%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/03/03/tvm/2020-03-03-TVM%20Android%20%E6%9E%84%E5%BB%BA%E6%97%B6%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/03/tvm/2020-03-03-TVM%20Android%20%E6%9E%84%E5%BB%BA%E6%97%B6%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%81/" class="post-title-link" itemprop="url">TVM Android 构建时千万不要用最新的工具！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-03 00:56:42" itemprop="dateCreated datePublished" datetime="2020-03-03T00:56:42+08:00">2020-03-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-28 17:37:08" itemprop="dateModified" datetime="2021-02-28T17:37:08+08:00">2021-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TVM-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">TVM 系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>遇到报错 <code>[INSTALL_FAILED_INVALID_APK: Failed to extract native libraries, res=-2]</code></p>
<p>修改 <code>AndroidManifest.xml</code> 的 <code>application</code> 字段，添加 <code>android:extractNativeLibs=&quot;true&quot;</code> 即可解决问题</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;true&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">&quot;@string/app\_name&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/03/tvm/2020-03-03-TVM%20Android%20%E6%9E%84%E5%BB%BA%E6%97%B6%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%81/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/03/03/tvm/2020-03-03-tvm-%E5%AE%89%E5%8D%93-rpc-%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/03/tvm/2020-03-03-tvm-%E5%AE%89%E5%8D%93-rpc-%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/" class="post-title-link" itemprop="url">TVM Android RPC 安卓部署踩坑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-03 00:42:51" itemprop="dateCreated datePublished" datetime="2020-03-03T00:42:51+08:00">2020-03-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-28 17:38:04" itemprop="dateModified" datetime="2021-02-28T17:38:04+08:00">2021-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TVM-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">TVM 系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><p><strong>环境</strong>：Ubuntu 18.04 LTS （非虚拟机）</p>
<p><strong>手机</strong>：Xiaomi Mi 5s, 3GB RAM, 64GB ROM</p>
<p><strong>系统</strong>：原生 Android 10</p>
<p><strong>遇到问题</strong>：android_rpc 无法编译部署</p>
<p><strong>解决方法</strong>：核心思路是分析 gradle task 执行顺序，分析相关脚本，检查环境变量。这个问题需要具体情况具体分析，请仔细查看本文【问题解决】部分的相关描述。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/03/tvm/2020-03-03-tvm-%E5%AE%89%E5%8D%93-rpc-%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2019/02/19/after_processed/2019-02-19-%E5%85%83%E5%AE%B5%E8%8A%82%E5%BF%AB%E4%B9%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/19/after_processed/2019-02-19-%E5%85%83%E5%AE%B5%E8%8A%82%E5%BF%AB%E4%B9%90/" class="post-title-link" itemprop="url">元宵节快乐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 23:58:56" itemprop="dateCreated datePublished" datetime="2019-02-19T23:58:56+08:00">2019-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-28 17:03:54" itemprop="dateModified" datetime="2021-02-28T17:03:54+08:00">2021-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天是2019年2月19日，元宵节，我并不快乐。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junyi</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  



    <div class="pjax">



    </div>
</body>
</html>
