<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"military-doctor.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown animate__faster","post_body":"fadeInDown animate__faster","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。 STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。 翻译过程未完结，具体内容请点击「阅读全文」">
<meta property="og:type" content="article">
<meta property="og:title" content="RFC5389 - Session Traversal Utilities for NAT 翻译">
<meta property="og:url" content="https://military-doctor.github.io/2020/06/27/2020-06-27-STUN/index.html">
<meta property="og:site_name" content="Junyi的小屋">
<meta property="og:description" content="STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。 STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。 翻译过程未完结，具体内容请点击「阅读全文」">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-27T12:10:49.000Z">
<meta property="article:modified_time" content="2021-03-20T08:53:37.084Z">
<meta property="article:author" content="Junyi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://military-doctor.github.io/2020/06/27/2020-06-27-STUN/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>RFC5389 - Session Traversal Utilities for NAT 翻译 | Junyi的小屋</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junyi的小屋</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a></li>
        <li class="menu-item menu-item-imwpc2021"><a href="/2021imwpc/" rel="section"><i class="fa fa-chess fa-fw"></i>2021 IMWPC</a></li>
        <li class="menu-item menu-item-friends"><a href="/friends/" rel="section"><i class="fa fa-user-friends fa-fw"></i>友情链接</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">说在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STUN"><span class="nav-number">2.</span> <span class="nav-text">STUN</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0-Overview-of-Operation"><span class="nav-number">2.1.</span> <span class="nav-text">3. 操作概述 Overview of Operation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9C%AF%E8%AF%AD-Terminology"><span class="nav-number">2.2.</span> <span class="nav-text">4. 术语 Terminology</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%9A%E4%B9%89-Definitions"><span class="nav-number">2.3.</span> <span class="nav-text">5. 定义 Definitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-STUN-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84-STUN-Message-Structure"><span class="nav-number">2.4.</span> <span class="nav-text">6. STUN 消息结构 STUN Message Structure</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Junyi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Junyi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Military-Doctor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Military-Doctor" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/06/27/2020-06-27-STUN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RFC5389 - Session Traversal Utilities for NAT 翻译
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-27 20:10:49" itemprop="dateCreated datePublished" datetime="2020-06-27T20:10:49+08:00">2020-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-20 16:53:37" itemprop="dateModified" datetime="2021-03-20T16:53:37+08:00">2021-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">未分类</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。</p>
<p>STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。</p>
<p>翻译过程未完结，具体内容请点击「阅读全文」</p>
<span id="more"></span>

<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>转载请注明作者及出处！</p>
<p>翻译中遇到的问题：</p>
<ul>
<li><input disabled="" type="checkbox"> 文章不能很好区分 indication 和 indication transaction</li>
<li><input disabled="" type="checkbox"> 存在不理解的内容以该格式进行标记 <font color="#D24C3D">?? 不理解的内容 ??</font></li>
</ul>
<p>还未检查的项目：</p>
<ul>
<li><input disabled="" type="checkbox"> 翻译的名词不会一个单词多个翻译。保证一致性</li>
<li><input disabled="" type="checkbox"> 句子结束的句号是否完整</li>
<li><input disabled="" type="checkbox"> 单词左右两边是否有空格</li>
<li><input disabled="" type="checkbox"> 大小写、拼写问题</li>
<li><input disabled="" type="checkbox"> 或、且，是否全都是左右两边加逗号</li>
</ul>
<p>译者注：</p>
<p>本翻译仅供参考，目的是让读者更好地理解 STUN 协议（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc5389/">RFC 5389</a>）。</p>
<p><u>我个人</u>对翻译的要求是逻辑严密准确，且文章<u>核心内容</u>与英文原版一致。</p>
<p>为了更方便读者理解，本翻译**<u>不保证</u>**部分措辞细节与英文原版一致。</p>
<p>为了保证文章的准确性，个别名词将不会进行翻译。</p>
<p>同样，为了保证文章的准确性，每句话的翻译都会附上英文原版供读者参考。</p>
<p>译者语文和英语的水平都不高，再次强调，本翻译仅供参考。</p>
<p>译者：Junyi</p>
<p>联系邮箱：me#junyi.pw (自行替换成 at 符号)</p>
<h1 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h1><p>STUN 全名叫 Session Traversal Utilities for NAT (STUN)</p>
<p>最新定义在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc5389/">RFC 5389</a></p>
<p>STUN 是一种协议，用于检查两个终端之间的连通性，可以工作在多种 NAT 之中，不需要 NAT 对其有任何行为。</p>
<p>STUN 本身不是一个 NAT 穿透的解决方案，而是一个 NAT 穿透条件检测工具。</p>
<p>STUN 最初定义在 RFC 3489，有时我们也说这个最初版本为“经典STUN” （classic STUN）</p>
<p>在那时候其实已经是一个完整的 NAT 穿透问题的解决方案了，客户端可以去发现自己是否在 NAT 之后，确定其所在 NAT 的类型，发现其经过 NAT 转换后的 IP 地址和端口号，利用这个IP地址和端口号执行 SIP（Session Initiation Protocol）。</p>
<p><strong>听起来挺美好的哈，但是随着我们的应用部署，发现经典的 STUN 有时候根本不工作！</strong></p>
<ul>
<li><p>通过 STUN 获取到的 IP 地址和端口信息有时候可以让两个 peer 互通，有时候不行</p>
</li>
<li><p>在 peer 不互通时，经典 STUN 没有提供补救措施</p>
</li>
<li><p>在有些 NAT 内，经典 STUN 的算法是错误的</p>
</li>
<li><p>经典 STUN 存在安全漏洞（攻击者可以给 peer 提供错误的映射地址、拓扑、约束）。这个问题无法从根本解决，我们最新的协议也只能缓解这个问题。</p>
</li>
</ul>
<p>基于以上原因，RFC 3489 已经被废弃。</p>
<h2 id="3-操作概述-Overview-of-Operation"><a href="#3-操作概述-Overview-of-Operation" class="headerlink" title="3. 操作概述 Overview of Operation"></a>3. 操作概述 Overview of Operation</h2><blockquote>
<p>This section is descriptive only.</p>
</blockquote>
<p>本节仅作描述性用途。</p>
<blockquote>
<p>STUN is a client-server protocol.</p>
</blockquote>
<p>STUN 是一种 client-server 协议，换句话讲，运行 STUN 协议实现的主机既可以充当客户端也可以充当服务器。</p>
<blockquote>
<p>It supports two types of transactions.  </p>
</blockquote>
<p>STUN 支持两种类型的事务。</p>
<blockquote>
<p>One is a <u>request/response transaction</u> in which a client sends a request to a server, and the server returns a response.</p>
</blockquote>
<p>其中一种是<u>请求/响应型事务</u>。就是说客户端发送一个 request 给服务器，服务器返回给客户端一个 response 。</p>
<blockquote>
<p>The second is an <u>indication transaction</u> in which either agent – client or server – sends an indication that generates no response. </p>
</blockquote>
<p>另一种是<u>指示型事物</u>。客户端或服务器只是<font color="#D24C3D">??发送一个指示，并没有任何 response。??</font></p>
<blockquote>
<p>Both types of transactions include a <u>transaction ID</u>, which is a randomly selected <u>96-bit</u> number.</p>
</blockquote>
<p>上述的两种事务类型，都包含一个随机选择的<u>96位</u>的<u>事务ID</u>。</p>
<blockquote>
<p>For <u>request/response transactions,</u> this transaction ID allows the client to associate the response with the request that generated it; for <u>indications</u>, the transaction ID serves as a debugging aid.</p>
</blockquote>
<p>对于<u>请求/响应型事务</u>，<font color="#D24C3D">??事务ID允许客户端将其生成的<u>请求事务</u>与收到的<u>响应事务</u>相关联。??</font></p>
<p>对于<u>指示型事物</u>，事务ID充当调试工具的角色。</p>
<blockquote>
<p>All STUN messages start with a fixed header that includes a <u>method</u>, a <u>class</u>, and the <u>transaction ID</u>.</p>
</blockquote>
<p>所有的 STUN 消息都以一个固定的头部开始。这个头部包含<u>方法</u>、<u>类</u>、<u>事物ID</u>[^1]</p>
<ul>
<li><blockquote>
<p>The <u>method</u> indicates which of the various <u>requests</u> or <u>indications</u> this is; this specification defines just one method, Binding, but other methods are expected to be defined in other documents.</p>
</blockquote>
<p><u>方法</u>表示这是哪种<u>请求</u>，或，这是哪种<u>指示</u>。在当前您阅读的这个 RFC 规范里，我们只规定了一种方法：Binding。（其他的方法有望在其他文档中定义）</p>
</li>
<li><blockquote>
<p>The <u>class</u> indicates whether this is a <u>request</u>, a <u>success response</u>, an <u>error response</u>, or an <u>indication</u>. </p>
</blockquote>
<p><u>类</u>表示这是一个<u>请求</u>、<u>成功的响应</u>、<u>错误的响应</u>还是一个<u>指示</u>。</p>
</li>
</ul>
<blockquote>
<p>Following the fixed header comes zero or more attributes, which are <u>Type-Length-Value</u> extensions that convey additional information for the specific message.</p>
</blockquote>
<p>紧跟在固定头部后面的是 0 个或多个 <u>Type-Length-Value</u> 扩展属性。不用细说，相信你也明白这个扩展属性的用途是为了传递附加信息。</p>
<hr>
<blockquote>
<p>This document defines a single <u>method</u> called Binding. The Binding method can be used either in request/response transactions or in indication transactions. </p>
</blockquote>
<p>这份文档只定义了 Binding 这个<u>方法</u>，这个方法既可以用在<u>请求/响应型事务</u>，又可以用在<u>指示型事物</u>。</p>
<blockquote>
<p>When used in <u>request/response transactions</u>, the Binding <u>method</u> can be used to determine the particular “binding” a NAT has allocated to a STUN client. When used in either <u>request/ response</u> <strong>or</strong> in <u>indication transactions</u>, the Binding <u>method</u> can also be used to keep these “bindings” alive.</p>
</blockquote>
<p>当在<u>请求/响应型事务</u>中使用 Binding <u>方法</u>时，它可以用来确定一个 NAT 分配给 STUN 客户端的特定 “绑定”。</p>
<p>当在<u>请求/响应型事务</u><strong>或</strong><u>指示型事物</u>中使用 Binding <u>方法</u>时，这个方法还可以用来维持这些特定 “绑定” 是活动的。</p>
<hr>
<blockquote>
<p>In the Binding <u>request/response transaction</u>, a <u>Binding request</u> is sent from a STUN client to a STUN server. </p>
</blockquote>
<p>在使用 Binding 方法的<u>请求/响应型事务</u>中，一条 <u>Binding 请求</u> 会从 STUN 客户端发往 STUN 服务器。</p>
<blockquote>
<p>When the <u>Binding request</u> arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server (in Figure 1, there were two such NATs).</p>
</blockquote>
<p>一条 <u>Binding 请求</u> 到达 STUN 服务器的过程里，可能会穿越 1 个或多个 NAT 设备。（在 Figure 1 中穿越了两个 NAT 设备）</p>
<blockquote>
<p>As the <u>Binding request</u> message passes through a NAT, the NAT will modify the <u>source transport address</u> (that is, the source IP address and the source port) of the packet. As a result, the <u>source transport address</u> of the request received by the server will be the <u>public IP address and port</u> created <strong>by the NAT closest to the server</strong>. This is called a <u>reflexive transport address</u>.</p>
</blockquote>
<p>在一个 <u>Bingding 请求</u> 数据包经过 NAT 的时候，NAT 会修改该数据包的<u>来源地址和端口</u>。</p>
<p>对于服务器来说，接收到的这份数据包的<u>来源地址和端口</u>其实是<strong>离服务器最近的 NAT的<u>公网 IP 地址和端口</u></strong> 。</p>
<p>这叫做 <u>reflexive transport address</u>。</p>
<p><font color="#D24C3D">??这个请求数据包的source地址叫做 reflexive transport address？??</font></p>
<blockquote>
<p>The STUN server copies that <u>source transport address</u> into an <u>XOR-MAPPED-ADDRESS</u> attribute in the STUN Binding response and sends the <u>Binding response</u> back to the STUN client. As this packet passes back through a NAT, the NAT will modify the <u><strong>destination</strong> transport address</u> in the IP header, but the transport address in the XOR-MAPPED-ADDRESS attribute within the body of the STUN response will remain untouched.</p>
</blockquote>
<p>接着，STUN 服务器会产生一个 <u>Binding 响应</u>，然后复制收到数据包的 <u>来源地址和端口</u> 到 <u>Binding 响应</u> 里的一个叫做 <u>XOR-MAPPED-ADDRESS</u> 的属性中，然后将 <u>Binding 响应</u> 发回 STUN 客户端。</p>
<p>这个响应数据包也会经过 NAT，NAT 会修改该数据包的<u><strong>目标</strong>地址和端口</u>。</p>
<p>注意，NAT 只会修改 IP 报头的地址和端口（来源或目标），不会修改 XOR-MAPPED-ADDRESS 中的内容。也就是说，NAT 只修改头部，不修改 Payload。</p>
<blockquote>
<p>In this way, the client can learn its reflexive transport address allocated by the <u>outermost NAT</u> with respect to the STUN server.</p>
</blockquote>
<p>通过这种方式，客户端可以了解到自己 <u>最外部 NAT</u> 给自己分配的的 reflexive transport address。</p>
<p>这里说的最外部，指的是相对于 STUN server 的最外部。套娃你懂吧，STUN server 有可能在一个非常大的子网里，这个时候客户端了解到的只是离 STUN 最近的那个 NAT 反射回的地址。</p>
<hr>
<blockquote>
<p>In some usages, STUN must be multiplexed with other protocols (e.g., [MMUSIC-ICE], [SIP-OUTBOUND]). In these usages, there must be a way to inspect a packet and determine if it is a STUN packet or not. </p>
</blockquote>
<p>在某些情况下， STUN 必须与其他协议复用（比如 MMUSIC-ICE, SIP-OUTBOUND）。在这些情况下，必须有一种方式来检测数据包是否为 STUN 协议类型。</p>
<blockquote>
<p>STUN provides three fields in the STUN header with fixed values that can be used for this purpose. If this is not sufficient, then STUN packets can also contain a <u>FINGERPRINT value</u>, which can further be used to distinguish the packets.</p>
</blockquote>
<p>STUN 在头部提供了三个字段用于其特殊情况下检测协议类型的目的。如果这三个字段仍然不够完成检测工作，那么 STUN 数据包中还可以通过包含 <u>FINGERPRINT 值</u> 来进一步区分数据包的协议类型。</p>
<hr>
<blockquote>
<p>STUN defines a set of optional procedures that a usage can decide to use, called <u>mechanisms</u>. These <u>mechanisms</u> include DNS discovery, a redirection technique to an <u>alternate server</u>, a fingerprint attribute for <u>demultiplexing</u>, and <u>two authentication</u> and <u>message-integrity exchanges</u>. The authentication mechanisms revolve around the use of a username, password, and message-integrity value. <u>Two authentication mechanisms</u>, the <u>long-term credential mechanism</u> and the <u>short-term credential mechanism</u>, are defined in this specification. </p>
</blockquote>
<p>STUN 定义了一系列的可选操作，称为<u>机制</u>。这些<u>机制</u>包含了：</p>
<ul>
<li><p><u>DNS发现</u>机制</p>
</li>
<li><p><u>备选服务器</u>的重定向机制</p>
</li>
<li><p><u>解多路复用</u>[^2]的 fingerprint 属性机制</p>
</li>
<li><p><u>双授权</u>机制</p>
</li>
<li><p><u>信息完整性交换</u>机制</p>
</li>
</ul>
<p>其中，<u>双授权机制</u>，在本手册中定义为<u>长期凭据机制</u>和<u>短期凭据机制</u>。</p>
<blockquote>
<p>Each usage specifies the mechanisms allowed with that usage.</p>
</blockquote>
<p>不同的使用场景决定了这些机制的具体用法。换句话讲，不同的使用场景被允许使用的机制是不同的。</p>
<hr>
<blockquote>
<p>In the long-term credential mechanism, the client and server share a pre-provisioned username and password and perform a <u>digest challenge / response exchange</u> inspired by (but differing in details) to the one defined for HTTP [RFC2617].</p>
</blockquote>
<p>在<u>长期凭据机制</u>里，客户端和服务器共享一个预先分配好的用户名和密码，然后执行 <u>digest challenge / response exchange</u>。</p>
<p>这个<u>长期凭据机制</u>受到 RFC 2617 的启发，但是具体细节上与 RFC 2617 不同。</p>
<blockquote>
<p>In the short-term credential mechanism, the client and the server exchange a username and password through some <u>out-of-band method</u> prior to the <u>STUN exchange</u>. For example, in the ICE usage [MMUSIC-ICE] the two endpoints use <u>out-of-band signaling</u> to exchange a username and password. These are used to <u>integrity protect</u> and <u>authenticate the request and response</u>. There is no challenge or nonce used.</p>
</blockquote>
<p>在<u>短期凭据机制</u>里，客户端和服务器在 <u>STUN 交换</u> 之前，通过一些 <u>out-of-band 的方式</u>[^3]来交换用户名和密码。举个例子，在 ICE中，两个端点使用 <u>out-of-band 信令</u> 来交换用户名和密码。它们被用来<u>保证消息的完整性</u>和<u>对请求和响应进行授权</u>。没有使用 challenge 或 nonce[^4]。</p>
<h2 id="4-术语-Terminology"><a href="#4-术语-Terminology" class="headerlink" title="4. 术语 Terminology"></a>4. 术语 Terminology</h2><blockquote>
<p>In this document, the key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in BCP 14, RFC 2119 [RFC2119] and indicate requirement levels for compliant STUN implementations.</p>
</blockquote>
<p>在这份文档中，“**<u><em>必须</em></u><strong>”，“</strong><u><em>必须不</em></u><strong>”，“</strong><u><em>必需要</em></u><strong>”，“</strong><u><em>应当</em></u><strong>”，“</strong><u><em>不应当</em></u><strong>”，“</strong><u><em>最好</em></u><strong>”，“</strong><u><em>最好不</em></u><strong>”，“</strong><u><em>建议</em></u><strong>”，“</strong><u><em>或许</em></u><strong>”，“</strong><u><em>可选</em></u>**”，将按照 BCP 14，RFC 2119 来解释说明 STUN 所需的的实现级别。</p>
<p><font color="red">因为中英文单词差异，所以在本翻译中，涉及到的上述词汇都会用**<u><em>粗体倾斜下划线</em></u>**来表示。</font></p>
<h2 id="5-定义-Definitions"><a href="#5-定义-Definitions" class="headerlink" title="5. 定义 Definitions"></a>5. 定义 Definitions</h2><blockquote>
<p>STUN Agent: A STUN agent is an entity that implements the STUN protocol. The entity can be either a STUN client or a STUN server.</p>
</blockquote>
<p><strong>STUN 代理</strong>：一个实现了 STUN 协议的实体被称为 STUN 代理。（既可以为客户端又可以为服务器）</p>
<blockquote>
<p>STUN Client: A STUN client is an entity that <u>sends STUN requests</u> and <u>receives STUN responses</u>. A STUN client can also send <u>indications</u>. In this specification, the terms <u>STUN client</u> and <u>client</u> are synonymous.</p>
</blockquote>
<p><strong>STUN 客户端</strong>：一个可以<u>发送 STUN 请求</u>，且，<u>接受 STUN 响应</u>的实体，被称为 STUN 客户端。STUN 客户端也可以发送<u>指示</u>[^5]。您可以理解 <u>STUN 客户端</u>和<u>客户端</u>是同义词。</p>
<blockquote>
<p>STUN Server: A STUN server is an entity that receives STUN requests and sends STUN responses. A STUN server can also send indications. In this specification, the terms <u>STUN server</u> and <u>server</u> are synonymous.</p>
</blockquote>
<p><strong>STUN 服务器</strong>：一个可以<u>接收 STUN 请求</u>，且，<u>发送 STUN 响应</u>的实体，被称为 STUN 服务器。STUN 服务器也可以发送<u>指示</u>[^5]。您可以理解 <u>STUN 服务器</u>和<u>服务器</u>是同义词。</p>
<blockquote>
<p>Transport Address: The combination of an <u>IP address</u> and port number (such as a UDP or TCP port number).</p>
</blockquote>
<p><strong>传输地址</strong>：<u>IP地址</u>和<u>端口</u>的组合被称为传输地址。</p>
<blockquote>
<p>Reflexive Transport Address: A transport address learned by a client that identifies that client as seen by another host on an IP network, typically a STUN server. When there is an intervening NAT between the client and the other host, the reflexive transport address represents the mapped address allocated to the client on <u>the public side of the NAT</u>. Reflexive transport addresses are learned from the mapped address attribute (<u>MAPPED-ADDRESS</u> or <u>XOR-MAPPED-ADDRESS</u>) in STUN responses.</p>
</blockquote>
<p><strong>反射性传输地址</strong>：一个客户端从“其他主机”那里了解到的自己的传输地址。一般这个“其他主机”指的是 STUN 服务器。当 NAT 干预在客户端与“其他主机”之间时，反射性传输地址代表了这个客户端在 <u>NAT 的公共区域那一侧</u>被分配到的传输地址。这个反射性传输地址被放在 STUN 响应的 <u>MAPPED-ADDRESS</u> 或 <u>XOR-MAPPED-ADDRESS</u> 里。</p>
<p>讲人话就是，客户端拿到的公网IP地址和端口号的组合就叫反射性传输地址。（不严谨，要想严谨还是得看上面的定义）</p>
<blockquote>
<p>Mapped Address: Same meaning as reflexive address. This term is retained only for historic reasons and due to the naming of the MAPPED-ADDRESS and XOR-MAPPED-ADDRESS attributes.</p>
</blockquote>
<p><strong>映射地址</strong>：跟反射性传输地址一样。这是个因为历史原因而保留下来的词。</p>
<blockquote>
<p>Long-Term Credential: A username and associated password that represent a shared secret between client and server. Long-term credentials are generally granted to the client when a subscriber enrolls in a service and persist until the subscriber leaves the service or explicitly changes the credential.</p>
</blockquote>
<p><strong>长期凭据</strong>：客户端和服务器共享的用户名密码。长期凭据通常在订阅者订阅一个服务时授予给客户端，并且一直持续到订阅者退出服务或显式更改凭据。</p>
<blockquote>
<p>Long-Term Password: The password from a long-term credential.</p>
</blockquote>
<p><strong>长期密码</strong>：长期凭据所使用的密码。</p>
<blockquote>
<p>Short-Term Credential: A <strong>temporary</strong> username and associated password that represent a shared secret between client and server. Short-term credentials are obtained through some kind of protocol mechanism between the client and server, preceding the <u>STUN exchange</u>. A short-term credential has an explicit temporal scope, which may be based on a specific amount of time (such as 5 minutes) or on an event (such as termination of a SIP dialog).</p>
<p>The specific scope of a short-term credential is defined by the application usage.</p>
</blockquote>
<p><strong>短期凭据</strong>：客户端和服务器共享的<strong>临时的</strong>用户名密码。短期凭据一般是在 <u>STUN 交换</u>之前，通过某种协议机制获得的。短期凭据有一个显式的时间范围，可能基于时间量（比如 5 分钟），或，基于事件（比如 SIP 对话的终止）。</p>
<p>具体的时间范围，由具体的应用程序使用场景决定。</p>
<blockquote>
<p>Short-Term Password: The password component of a short-term credential.</p>
</blockquote>
<p><strong>短期密码</strong>：短期凭据所使用的密码。</p>
<blockquote>
<p>STUN Indication: A STUN message that does not receive a response.</p>
</blockquote>
<p><strong>STUN 指示</strong>：一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p>
<blockquote>
<p>Attribute: The STUN term for a Type-Length-Value (TLV) object that can be added to a STUN message. Attributes are divided into two types: <u>comprehension-required</u> and <u>comprehension-optiona</u>l. <u>STUN agents</u> can safely ignore <u>comprehension-optional</u> attributes they don’t understand, but cannot successfully process a message if it contains comprehension-required attributes that are not understood.</p>
</blockquote>
<p><strong>属性</strong>：一个 TLV 对象可以被附加在 STUN 消息里。一共有两种类型的属性：<u>必须要理解的</u>和<u>可选理解的</u>。<u>STUN 代理</u> 可以安全的忽略那些它们无法理解的、<u>可选理解的</u>属性，但是无法成功处理它们无法理解的、<u>必须要理解的</u>属性。</p>
<blockquote>
<p>RTO: Retransmission TimeOut, which defines the initial period of time between transmission of a request and the first retransmit of that request.</p>
</blockquote>
<p><strong>RTO</strong>：重传超时。也就是从请求传输到第一次重新传输之间的时间。</p>
<h2 id="6-STUN-消息结构-STUN-Message-Structure"><a href="#6-STUN-消息结构-STUN-Message-Structure" class="headerlink" title="6. STUN 消息结构 STUN Message Structure"></a>6. STUN 消息结构 STUN Message Structure</h2><blockquote>
<p><u>STUN messages</u> are encoded in binary using network-oriented format (most significant byte or octet first, also commonly known as big-endian). The transmission order is described in detail in Appendix B of RFC 791 [RFC0791]. Unless otherwise noted, numeric constants are in decimal (base 10).</p>
</blockquote>
<p><u>STUN 消息</u>使用 MSB 的二进制格式编码（big-endian）。传输顺序在 RFC 791 的 Appendix B 中有详细描述。除了特别注明之外，数字常量都以 10 进制表示。</p>
<blockquote>
<p>All <u>STUN messages</u> MUST start with a 20-byte header followed by zero or more <strong>Attributes</strong>. The STUN header contains a <u>STUN message type</u>, <u>magic cookie</u>, <u>transaction ID</u>, and <u>message length</u>.</p>
</blockquote>
<p>所有的 <u>STUN 消息</u> <strong><em><u>必须</u></em></strong> 以 20-byte 长度的头部开始，紧跟着 0 个 或 多个<strong>属性</strong>。STUN 头部包含了 <u>STUN 消息类型</u>、<u>magic cookie</u>、<u>事务ID</u>、<u>消息长度</u>。</p>
<pre class="line-numbers language-none"><code class="language-none"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type    |         Message Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  Figure 2: Format of STUN Message Header<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p>The most significant 2 bits of every <u>STUN message</u> MUST be zeroes. This can be used to differentiate <u>STUN packet</u>s from other protocols when STUN is multiplexed with other protocols on the same port.</p>
</blockquote>
<p>每条 <u>STUN 消息</u> 的最高 2 bit <strong><u><em>必须</em></u></strong> 为零。这可以在 STUN 与其他协议在同一端口复用时，区分 <u>STUN 数据包</u>。</p>
<blockquote>
<p>The <u>message type</u> defines the message class (<u>request</u>, <u>success response</u>, <u>failure response</u>, or <u>indication</u>) and the message <u>method</u> (the primary function) of the STUN message. Although there are four message classes, there are only two types of transactions in STUN: <u>request/response transactions</u> (which consist of a request message and a response message) and <u>indication transactions</u> (which consist of a single <strong><u>indication</u></strong> message). Response classes are split into error and success responses to aid in quickly processing the STUN message.</p>
</blockquote>
<p><u>STUN 消息类型</u>定义了消息所属的类（<u>请求</u>，<u>成功的响应</u>，<u>失败的响应</u>，<u>指示</u>），和，一条 STUN 消息的<u>方法（主要功能）</u>[^6]</p>
<p>尽管有四种消息所属的类，但在 STUN 中只有两种事务类型：<u>请求/响应型事务</u>（包含请求消息和响应消息），和，<u>指示型事务</u>（包含单独的一条<u><strong>STUN 指示</strong></u>[^7]消息）。响应类被划分为<u>失败的响应</u>和<u>成功的响应</u>，目的是帮助快速处理 STUN 消息。</p>
<p>更直观一点来讲：</p>
<ul>
<li>Transaction Type：请求/响应型事务<ul>
<li>Message Type：请求</li>
<li>Message Type：成功的响应</li>
<li>Message Type：失败的响应</li>
</ul>
</li>
<li>Transaction Type：指示型事务<ul>
<li>Message Type：指示</li>
</ul>
</li>
</ul>
<blockquote>
<p>The message type field is decomposed further into the following structure:</p>
</blockquote>
<p><strong>STUN Message Type</strong> 字段被分解成以下结构：</p>
<pre class="line-numbers language-none"><code class="language-none"> 0                 1
 2  3  4 5 6 7 8 9 0 1 2 3 4 5 
+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
|M |M |M|M|M|C|M|M|M|C|M|M|M|M|
|11|10|9|8|7|1|6|5|4|0|3|2|1|0|
+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
Figure 3: Format of STUN Message Type Field<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p>Here the bits in the message type field are shown as most significant (M11) through least significant (M0). M11 through M0 represent a 12-bit encoding of the <u>method</u>. C1 and C0 represent a 2-bit encoding of the <u>class</u>. A class of 0b00 is a <u>request</u>, a class of 0b01 is an <u>indication</u>, a class of 0b10 is a <u>success response</u>, and a class of 0b11 is an <u>error response</u>. This specification defines a single method, Binding. <strong>The method and class are orthogonal, so that for each method, a <u>request</u>, <u>success response</u>, <u>error response</u>, and <u>indication</u> are possible for that method.</strong> Extensions defining new methods MUST indicate which <u>classes</u> are permitted for that method.</p>
</blockquote>
<p>Message Type 字段从最高有效位（M11）开始到最低有效位（M0）结束。M11 到 M0 一共是 12-bit，这12个bit编码了<u>方法</u>。 C1 和 C- 表示<u>类</u>，由2个bit组成。0b00 表示一个<u>请求</u>，0b01 表示一个<u>指示</u>，0b10 表示一个<u>成功的响应</u>，0b11 表示一个<u>失败的响应</u>。</p>
<p>当前文档里定义了一个单独的方法，Bingding。方法和类是<font color="red">??正交??</font>的关系，<strong>因此对于每个方法，都要有<u>请求</u>、<u>指示</u>、<u>成功的响应</u>、<u>失败的响应</u>。</strong></p>
<p>定义新的扩展方法时 <strong><u><em>必须</em></u></strong> 指明允许哪些<u>类</u></p>
<blockquote>
<p>For example, a Binding <u>request</u> has class=0b00 (request) and method=0b000000000001 (Binding) and is encoded into the first 16 bits as 0x0001. A Binding response has class=0b10 (success response) and method=0b000000000001, and is encoded into the first 16 bits as 0x0101.</p>
</blockquote>
<p>例如，一个 Binding 方法的<u>请求</u>的类的编码为 0b00，方法号为 0b000000000001。前16个bit的十六进制编码为 0x0001。Binding 方法的响应的类的编码为 0b10，方法号同样为 0b000000000001，前16个bit的十六进制编码为 0x0101。</p>
<p>译者补充：注意，您可能会好奇，类的编码长度为2bit，方法编码长度为12bit，加起来一共14bit，为什么这里说前16bit呢？原因是，这里说的前16个bit，指的是 <u>STUN 消息</u>（或着说 STUN 数据包）的前16bit，对于一个 STUN 消息，最高位的 2bit 是被保留的，还记得吗？</p>
<blockquote>
<p>Note: This unfortunate encoding is due to assignment of values in [RFC3489] that did not consider encoding Indications, Success, and Errors using bit fields.</p>
</blockquote>
<p>请注意：</p>
<p>The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order. In RFC 3489 [RFC3489], this field was part of the transaction ID; placing the magic cookie in this location allows a server to detect if the client will understand certain attributes that were added in this revised specification. In addition, it aids in distinguishing STUN packets from packets of other protocols when STUN is multiplexed with those other protocols on the same port.</p>
<p>[^1]: 还记得吗，<u>事务ID</u>是一个随机选择的 96位 的数字<br>[^2]: 解多路复用就是与多路复用的作用相反的一个过程<br>[^3]: In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_networking">computer networking</a>, <strong>out-of-band data</strong> is the data transferred through a stream that is independent from the main <em>in-band</em> data stream.<br>[^4]: 在資訊安全中，Nonce是一個在加密通訊只能使用一次的數字。在認證協定中，它往往是一個隨機或偽隨機數，以避免重送攻擊。<br>[^5]: indicatino 在 indication transaction 中被发送。 <u>指示</u> 在 <u>指示型事务</u> 中被发送<br>[^6]: The <u>method</u> indicates which of the various <u>requests</u> or <u>indications</u> this is. <u>方法</u>表示这是哪种<u>请求</u>，或，这是哪种<u>指示</u>。<br>[^7]: 一个不接收响应的 STUN 消息。（说人话就是只发不收，就告诉你一声。）</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/26/2020-06-26-P2P%E6%8A%80%E6%9C%AF%E4%B8%80/" rel="prev" title="P2P 技术 （一）">
                  <i class="fa fa-chevron-left"></i> P2P 技术 （一）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/02/2020-08-02-Payload_Flexible_FEC/" rel="next" title="RFC8627 - Payload Flexible FEC 翻译">
                  RFC8627 - Payload Flexible FEC 翻译 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junyi</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  



    <div class="pjax">


<script>
NexT.utils.loadComments('.utterances-container', () => {
  const script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', "Military-Doctor/Military-Doctor.github.io");
  script.setAttribute('issue-term', "pathname");
  script.setAttribute('theme', "preferred-color-scheme");
  script.crossOrigin = 'anonymous';
  script.async = true;
  document.querySelector('.utterances-container').appendChild(script);
});
</script>

    </div>
</body>
</html>
