<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"military-doctor.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown animate__faster","post_body":"fadeInDown animate__faster","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="FEC 还蛮有意思的，这篇翻译的内容是 Payload Flexible FEC 的 RFC 细节 具体内容请点击「阅读全文」">
<meta property="og:type" content="article">
<meta property="og:title" content="RFC8627 - Payload Flexible FEC 翻译">
<meta property="og:url" content="https://military-doctor.github.io/2020/08/02/2020-08-02-Payload_Flexible_FEC/index.html">
<meta property="og:site_name" content="Junyi的小屋">
<meta property="og:description" content="FEC 还蛮有意思的，这篇翻译的内容是 Payload Flexible FEC 的 RFC 细节 具体内容请点击「阅读全文」">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-02T03:08:57.000Z">
<meta property="article:modified_time" content="2021-03-20T08:53:20.776Z">
<meta property="article:author" content="Junyi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://military-doctor.github.io/2020/08/02/2020-08-02-Payload_Flexible_FEC/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>RFC8627 - Payload Flexible FEC 翻译 | Junyi的小屋</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Junyi的小屋</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a></li>
        <li class="menu-item menu-item-imwpc2021"><a href="/2021imwpc/" rel="section"><i class="fa fa-chess fa-fw"></i>2021 IMWPC</a></li>
        <li class="menu-item menu-item-friends"><a href="/friends/" rel="section"><i class="fa fa-user-friends fa-fw"></i>友情链接</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Payload-Flexible-FEC"><span class="nav-number">1.</span> <span class="nav-text">Payload Flexible FEC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Definitions-and-Notations"><span class="nav-number">2.</span> <span class="nav-text">3. Definitions and Notations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Definitions"><span class="nav-number">2.1.</span> <span class="nav-text">3.1 Definitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Notations"><span class="nav-number">2.2.</span> <span class="nav-text">3.2 Notations</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Packet-Formats-%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">4. Packet Formats 包格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Source-Packets-%E6%BA%90%E5%8C%85"><span class="nav-number">3.1.</span> <span class="nav-text">4.1. Source Packets 源包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Repair-Packets-%E4%BF%AE%E5%A4%8D%E5%8C%85"><span class="nav-number">3.2.</span> <span class="nav-text">4.2. Repair Packets 修复包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Payload-Format-Parameters-%E8%BD%BD%E8%8D%B7%E6%A0%BC%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">5. Payload Format Parameters 载荷格式参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Media-Type-Registration-Parity-Codes-%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C-%E5%A5%87%E5%81%B6%E7%A0%81"><span class="nav-number">4.1.</span> <span class="nav-text">5.1. Media Type Registration - Parity Codes 媒体类型注册 - 奇偶码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Mapping-to-SDP-Parameters-%E5%88%B0-SDP-%E5%8F%82%E6%95%B0%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">4.2.</span> <span class="nav-text">5.2. Mapping to SDP Parameters 到 SDP 参数的映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-Offer-Answer-Model-Considerations"><span class="nav-number">4.2.1.</span> <span class="nav-text">5.2.1. Offer-Answer Model Considerations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-Declarative-Considerations"><span class="nav-number">4.2.2.</span> <span class="nav-text">5.2.2. Declarative Considerations</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Protection-and-Recovery-Procedures-Parity-Codes-%E4%BF%9D%E6%8A%A4%E5%92%8C%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B-%E5%A5%87%E5%81%B6%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">6. Protection and Recovery Procedures - Parity Codes 保护和恢复过程 - 奇偶码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Overview-%E6%A6%82%E8%A7%88"><span class="nav-number">5.1.</span> <span class="nav-text">6.1. Overview 概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Repair-Packet-Construction-%E4%BF%AE%E5%A4%8D%E5%8C%85%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">5.2.</span> <span class="nav-text">6.2. Repair Packet Construction 修复包的构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Source-Packet-Reconstruction-%E9%87%8D%E5%BB%BA%E6%BA%90%E5%8C%85"><span class="nav-number">5.3.</span> <span class="nav-text">6.3. Source Packet Reconstruction 重建源包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-Associating-the-Source-and-Repair-Packets-%E6%BA%90%E5%8C%85%E4%B8%8E%E4%BF%AE%E5%A4%8D%E5%8C%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-number">5.3.1.</span> <span class="nav-text">6.3.1. Associating the Source and Repair Packets 源包与修复包之间的关联</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-1-Signaled-in-SDP-%E5%9C%A8SDP%E4%B8%AD%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">6.3.1.1. Signaled in SDP 在SDP中的交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-2-Using-bitmasks"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">6.3.1.2. Using bitmasks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-3-Using-M-and-Offsets"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">6.3.1.3. Using M and Offsets</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-Recovering-the-RTP-Header-%E6%81%A2%E5%A4%8D-RTP-%E5%A4%B4"><span class="nav-number">5.3.2.</span> <span class="nav-text">6.3.2. Recovering the RTP Header 恢复 RTP 头</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-SDP-Examples-%E6%9C%89%E5%85%B3-SDP-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">7. SDP Examples 有关 SDP 的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Example-SDP-for-Flexible-FEC-Protection-with-in-band-SSRC-mapping"><span class="nav-number">6.1.</span> <span class="nav-text">7.1. Example SDP for Flexible FEC Protection with in-band SSRC mapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Example-SDP-for-Flex-FEC-Protection-with-explicit-signalling-in-the-SDP"><span class="nav-number">6.2.</span> <span class="nav-text">7.2. Example SDP for Flex FEC Protection with explicit signalling in the SDP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Congestion-Control-Considerations-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E8%80%83%E8%99%91"><span class="nav-number">7.</span> <span class="nav-text">8. Congestion Control Considerations 拥塞控制的考虑</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Security-Considerations-%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91"><span class="nav-number">8.</span> <span class="nav-text">9. Security Considerations 安全考虑</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-IANA-Considerations"><span class="nav-number">9.</span> <span class="nav-text">10. IANA Considerations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Acknowledgements"><span class="nav-number">10.</span> <span class="nav-text">11. Acknowledgements</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Junyi"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Junyi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Military-Doctor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Military-Doctor" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://military-doctor.github.io/2020/08/02/2020-08-02-Payload_Flexible_FEC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Junyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junyi的小屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RFC8627 - Payload Flexible FEC 翻译
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-02 11:08:57" itemprop="dateCreated datePublished" datetime="2020-08-02T11:08:57+08:00">2020-08-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-20 16:53:20" itemprop="dateModified" datetime="2021-03-20T16:53:20+08:00">2021-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">未分类</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>FEC 还蛮有意思的，这篇翻译的内容是 Payload Flexible FEC 的 RFC 细节</p>
<p>具体内容请点击「阅读全文」</p>
<span id="more"></span>

<h1 id="Payload-Flexible-FEC"><a href="#Payload-Flexible-FEC" class="headerlink" title="Payload Flexible FEC"></a>Payload Flexible FEC</h1><h1 id="3-Definitions-and-Notations"><a href="#3-Definitions-and-Notations" class="headerlink" title="3. Definitions and Notations"></a>3. Definitions and Notations</h1><h2 id="3-1-Definitions"><a href="#3-1-Definitions" class="headerlink" title="3.1 Definitions"></a>3.1 Definitions</h2><h2 id="3-2-Notations"><a href="#3-2-Notations" class="headerlink" title="3.2 Notations"></a>3.2 Notations</h2><h1 id="4-Packet-Formats-包格式"><a href="#4-Packet-Formats-包格式" class="headerlink" title="4. Packet Formats 包格式"></a>4. Packet Formats 包格式</h1><p>这一节定义了源包和修复包的格式</p>
<h2 id="4-1-Source-Packets-源包"><a href="#4-1-Source-Packets-源包" class="headerlink" title="4.1. Source Packets 源包"></a>4.1. Source Packets 源包</h2><pre class="line-numbers language-none"><code class="language-none">The source packets MUST contain the information that identifies the
source block and the position within the source block occupied by the
packet.  Since the source packets that are carried within an RTP
stream already contain unique sequence numbers in their RTP headers
[RFC3550], we can identify the source packets in a straightforward
manner and there is no need to append additional field(s).  The
primary advantage of not modifying the source packets in any way is
that it provides backward compatibility for the receivers that do not
support FEC at all.  In multicast scenarios, this backward
compatibility becomes quite useful as it allows the non-FEC-capable
and FEC-capable receivers to receive and interpret the same source
packets sent in the same multicast session.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="4-2-Repair-Packets-修复包"><a href="#4-2-Repair-Packets-修复包" class="headerlink" title="4.2. Repair Packets 修复包"></a>4.2. Repair Packets 修复包</h2><p>修复包中必须有能够区分 source block they pertain to 和 the relationship between the contained repair symbols and the original source block.</p>
<p>针对这个要求，修复包使用 RTP 的头，以及 RTP 载荷中的另一个头，我们把它叫做 FEC 头，具体请看 Figure 9</p>
<pre class="line-numbers language-none"><code class="language-none">+------------------------------+
|          IP Header           |
+------------------------------+
|       Transport Header       |
+------------------------------+
|          RTP Header          | __
+------------------------------+   |
|          FEC Header          |    \
+------------------------------+     &gt; RTP Payload
|        Repair Symbols        |    &#x2F;
+------------------------------+ __|

        Figure 9: Format of repair packets<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，被 FEC 保护的所有 包，必须在同一个 RTP session 里</p>
<p>RTP 的头部根据 RFC3550 所定义，添加了进一步的 clarifications：</p>
<ul>
<li>Marker (M) Bit：这个 bit 不是给这个 payload type 用的，所以应该被设置成 0</li>
<li>Payload Type：修复包的(动态)载荷类型由带外方式确定。根据 RFC3550 中的定义，RTP接受者收到不能识别的PayloadType包时，会将整个包丢掉。这个特点提供了后向兼容性。如果一个不支持 FEC 的接受者收到了修复包，它将不能识别修复包的 payload type，从而丢掉修复包</li>
<li>Sequence Number（SN）：序列号有一个标准的定义，它的值必须大于上次传输修复包所用的值。初始值应该是随机生成的（不可预测的）</li>
<li>Timestamp（TS）：是叫戳应该被设置成修复包被传输时的时间。这个时间戳不是用来给 FEC 做纠错用的，通常是给 jitter calculation 用的。</li>
<li>Synchronization Source（SSRC）：根据 RFC3550，这个 SSRC 值应该被随机分配。这允许发送者在同一个端口复用源包和修复包，或者在同一端口复用多个修复包。<strong>修复流</strong> SHOULD 使用 RTCP CNAME 字段把自己跟<strong>源流</strong>关联。在一些网络里，同时产生源包和修复包的RTP源可能不是同一个主机。在这个场景里，给源流和修复流使用同样的 CNAME 意味着RTP源和FEC源必须共享同一个 CNAME。基于一个已知的算法和RTP、FEC源，一个公共的 CNAME 可能被产生（RFC7022）。这个用法符合 RFC3550 中的定义。<font color="red"><strong>注意，由于是随机分配 SSRC，这里有可能会造成 SSRC 冲突。发生冲突时，必须按照 RFC3550 中的定义去解决冲突。</strong></font></li>
</ul>
<ul>
<li><pre class="line-numbers language-none"><code class="language-none"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|R|F| P|X|  CC   |M| PT recovery |         length recovery      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   SSRCCount   |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             SSRC_i                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           SN base_i           |k|          Mask [0-14]        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|k|                   Mask [15-45] (optional)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|k|                                                             |
+-+                   Mask [46-108] (optional)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     ... next in SSRC_i ...                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Figure 10: Format of the FEC header<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
</ul>
<p>FEC 头部包含以下字段：</p>
<ul>
<li><p>R bit 去表示这是一个重传包的话必须设置成1，<strong>对于修复包必须设置成0</strong></p>
</li>
<li><p>F 字段表示 mask 的类型：</p>
</li>
<li><pre class="line-numbers language-none"><code class="language-none">+---------------+-------------------------------------+
|     F bit     | Use                                 |
+---------------+-------------------------------------+
|       0       | flexible mask                       |
|       1       | packets indicated by offset M and N |
+---------------+-------------------------------------+
  
  
                      Figure 11: F-bit values<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>P, X, CC, M 和 PT recovery 字段用户确定被恢复包的字段</p>
</li>
<li><p>Length Recovery （16-bit）字段被用来确定恢复包的长度</p>
</li>
<li><p>TS recovery（32-bit）字段被用来确定恢复包的时间戳</p>
</li>
<li><p>SSRC count（8-bit）字段描述了 FEC 包保护的 SSRC 的数量。0不是一个有效值，并且这个包 MUST 被忽略。</p>
</li>
<li><p>Reserved（24-bit）为了未来的用途而被保留。它 MUST 被发送者设置成 0，并且被接受者忽略</p>
</li>
<li><p>SSRC_i（32-bit）字段描述了当前这个特定的 FEC 包保护了哪个 SSRC。如果 FEC 包保护了多个 SSRC（SSRC count &gt; 1），那么这里将会有多个 blocks of data 包含 SSRC, SN base 和 Mask Fields.</p>
</li>
<li><p>SN base_i（16-bit）字段表示此修复包保护的特定 SSRC（在SSRC_i中指示）的源包的最低序号（考虑到回绕）【译者：我不知道什么是回绕 wrap around into account】</p>
</li>
<li><p>如果 F bit 被设置成0，则表示这个特定的修复包所保护的源包的所有 SSRC 使用 flexible bitmask 来处理。对于一个被 FEC 保护的特定的 SSRC_i 包，mask 是一个游程编码（run-length encoding）。第 j 位设置成 1 表示 源包的序列号（SN base_i + j + 1）被这个FEC包所保护。</p>
</li>
<li><p>bitmask中的 k-bit 表示这是一个 15-,46-或109-bitmask。k=0 表示这里有一个以上的 k-bit set，k=1 表示这是 bit mask 中最后一个 block。当解析一个头的时候，当前的 k-bit 数量决定了 bit mask v 的大小：</p>
</li>
<li><p>$$<br>size_of_next_bitmast = 2^{count(k)+3}-1<br>$$</p>
</li>
<li><pre class="line-numbers language-none"><code class="language-none"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|0| P|X|  CC  |M| PT recovery |         length recovery       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   SSRCCount   |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             SSRC_i                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           SN base_i           |k|          Mask [0-14]        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|k|                   Mask [15-45] (optional)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|k|                                                             |
+-+                   Mask [46-108] (optional) 
|
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     ... next in SSRC_i ...                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          Figure 12: Protocol format for F&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果 F-bit 被设置成1，它表示被这个特定修复包所保护的源包中的所有 SSRC 使用固定 offset</p>
</li>
<li><pre class="line-numbers language-none"><code class="language-none"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|0| P|X|  CC  |M| PT recovery |         length recovery       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          TS recovery                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   SSRCCount   |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             SSRC_i                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           SN base_i           |  M (columns)  |    N (rows)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             Figure 13: Protocol format for F&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><pre class="line-numbers language-none"><code class="language-none">Consequently, the following conditions occur for M and N values:

If M&gt;0, N&#x3D;0,  is Row FEC, and no column FEC will follow
            Hence, FEC &#x3D; SN, SN+1, SN+2, ... , SN+(M-1), SN+M.
 
If M&gt;0, N&#x3D;1,  is Row FEC, and column FEC will follow.
              Hence, FEC &#x3D; SN, SN+1, SN+2, ... , SN+(M-1), SN+M.
         and more to come
 
If M&gt;0, N&gt;1,  indicates column FEC of every M packet
                 in a group of N packets starting at SN base.
              Hence, FEC &#x3D; SN+(Mx0), SN+(Mx1), ... , SN+(MxN).

          Figure 14: Interpreting the M and N field values<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>通过设置 R 为 1，F 为 1，这个 FEC 就只保护一个包了。比如，SN Base_i 表示了FEC 载荷承载着的包，这是一种非常有效的重传包的方法。特别注意的是，解析这种包非常特别。序列号（SN base_i）替代了 FEC 包中 length recovery 字段。SSRC_count 应该为 1，M 和 N 应该为 0，并且 FEC 头的 reserved bits 也不复存在。通过这个方法我们可以省下 64 bits。</p>
</li>
<li><pre class="line-numbers language-none"><code class="language-none"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|1| P|X|  CC  |M| PT recovery |        sequence number        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              SSRC                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Retransmission                        |
:                            payload                            :
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  
        Figure 15: Protocol format for Retransmission<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ul>
<p>在 Section 6.2 里描述了设置这些字段的细节</p>
<p>需要注意的是，mask-based 的方法（与 RFC2733 和 RFC5109 中很相似）可能不是非常有效的指明在当前 source block 中修复包与哪个源包关联。特别的是，对于想使用 large source block size 的应用程序来说，描述源包-修复包 的这个关联，所需的 mask 可能大的令人难以接受。</p>
<p>[SMPTE2022-1]中提出的8位字段指示一种系统化的方法。 相反，本文档中的方法使用8位字段指示受FEC数据包保护的数据包偏移量。 [SMPTE2022-1]中的方法本质上对于常规模式更有效，但不能提供表示其他保护模式的灵活性（比如：staircase）</p>
<h1 id="5-Payload-Format-Parameters-载荷格式参数"><a href="#5-Payload-Format-Parameters-载荷格式参数" class="headerlink" title="5. Payload Format Parameters 载荷格式参数"></a>5. Payload Format Parameters 载荷格式参数</h1><p>这一章节提供了对于非交错和交错的奇偶FEC的媒体子类型注册。这一章也通过这些参数配置 FEC 编码和解码。如果没有特定的 FEC code 被子类型所指明，那么 FEC code 默认是这一章里定义的奇偶码（parity code）。</p>
<h2 id="5-1-Media-Type-Registration-Parity-Codes-媒体类型注册-奇偶码"><a href="#5-1-Media-Type-Registration-Parity-Codes-媒体类型注册-奇偶码" class="headerlink" title="5.1. Media Type Registration - Parity Codes 媒体类型注册 - 奇偶码"></a>5.1. Media Type Registration - Parity Codes 媒体类型注册 - 奇偶码</h2><table>
<thead>
<tr>
<th></th>
<th>audio/flexfec</th>
<th>video/flexfec</th>
<th>text/flexfec</th>
<th>application/flexfec</th>
</tr>
</thead>
<tbody><tr>
<td>Type name</td>
<td>audio</td>
<td>video</td>
<td>text</td>
<td>application</td>
</tr>
<tr>
<td>Subtype name</td>
<td>flexfec</td>
<td>flexfec</td>
<td>flexfec</td>
<td>flexfec</td>
</tr>
<tr>
<td>Required param: rate</td>
<td>The RTP timestamp (clock) rate.  The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Required param: repair-window</td>
<td>The time that spans the source packets and the corresponding repair packets.  The size of the repair window is specified in microseconds.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: L</td>
<td>indicates the number of columns of the source block that are protected by this FEC block and it applies to all the source SSRCs.  L is a positive integer.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: D</td>
<td>indicates the number of rows of the source block that are protected by this FEC block and it applies to all the source SSRCs.  D is a positive integer.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Optional param: ToP</td>
<td>indicates the type of protection applied by the sender: 0 for 1-D interleaved FEC protection, 1 for 1-D non-interleaved FEC protection, and 2 for 2-D parity FEC protection.  The ToP value of 3 is reserved for future uses.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Encoding considerations</td>
<td>This media type is framed (See Section 4.8    in the template document [RFC6838]) and contains binary data.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Security considerations</td>
<td>See Section 9 of [RFCXXXX]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Interoperability considerations</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Published specification</td>
<td>[RFCXXXX]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Applications that use this media type:</td>
<td>Multimedia applications that    want to improve resiliency against packet loss by sending redundant    data in addition to the source media.</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Fragment identifier considerations:</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Additional information</td>
<td>None</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Intended usage</td>
<td>COMMON</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Restriction on usage</td>
<td>This media type depends on RTP framing, and    hence, is only defined for transport via RTP [RFC3550]</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
<tr>
<td>Provisional registration? (standards tree only)</td>
<td>Yes</td>
<td>Same</td>
<td>Same</td>
<td>Same</td>
</tr>
</tbody></table>
<h2 id="5-2-Mapping-to-SDP-Parameters-到-SDP-参数的映射"><a href="#5-2-Mapping-to-SDP-Parameters-到-SDP-参数的映射" class="headerlink" title="5.2. Mapping to SDP Parameters 到 SDP 参数的映射"></a>5.2. Mapping to SDP Parameters 到 SDP 参数的映射</h2><p>The mapping of the media type specification for “non-interleaved-parityfec” and “interleaved-parityfec” and their parameters in SDP is as follows:</p>
<ul>
<li>The media type (e.g., “application”) goes into the “m=” line as the media name.</li>
<li>The media subtype goes into the “a=rtpmap” line as the encoding name.  The RTP clock rate parameter (“rate”) also goes into the “a=rtpmap” line as the clock rate.</li>
<li>The remaining required payload-format-specific parameters go into the “a=fmtp” line by copying them directly from the media type string as a semicolon-separated list of parameter=value pairs.</li>
</ul>
<p>有关 SDP 的例子请看 Section 7.</p>
<h3 id="5-2-1-Offer-Answer-Model-Considerations"><a href="#5-2-1-Offer-Answer-Model-Considerations" class="headerlink" title="5.2.1. Offer-Answer Model Considerations"></a>5.2.1. Offer-Answer Model Considerations</h3><p>When offering 1-D interleaved parity FEC over RTP using SDP in an Offer/Answer model [RFC3264], the following considerations apply:</p>
<ul>
<li>不同 L 和 D 的组合会产生不同的 FEC 数据，并且无法与其它组合相互使用。发送者可能会想要提供多个有效的 L 和 D 的组合供接收者使用。接收者 SHOULD 正常选择有足够的 interleaving 的 offer。如果多个 offer 存在，接收者可能选择最低开小的或需要最小缓冲区的 offer。具体的选择跟场景要求有关</li>
<li>Repair-window 的值依赖于 L 和 D 的值，不能随便写。更具体的来讲，L 和 D 的值决定了 repair-window 大小的下限（最小值）。repair-window 的上限并不由 L 和 D 来决定。</li>
<li>在相同的 L 和 D 条件下，就算 repair-window 的值不同，也会产生相同的 FEC 数据，不过，不同的 repair-window 和 相同L/D 的组合，仍然被视作不同的 offer。repair-window 会影响到传输源包的最大延迟，因为直接影响到了 receiver 的 buffering 的条件，所以在选择 offer 的时候 receiver 必须考虑延迟。</li>
<li>There are no optional format parameters defined for this payload. Any unknown option in the offer MUST be ignored and deleted from the answer. 如果客户端不想要 FEC，那么 answer 里就会把 FEC 去掉</li>
</ul>
<p>这里说的 offer 指的是 L、D 和 repair-window 的组合</p>
<h3 id="5-2-2-Declarative-Considerations"><a href="#5-2-2-Declarative-Considerations" class="headerlink" title="5.2.2. Declarative Considerations"></a>5.2.2. Declarative Considerations</h3><p>In declarative usage, like SDP in the Real-time Streaming Protocol (RTSP) [RFC2326] or the Session Announcement Protocol (SAP) [RFC2974], the following considerations apply:</p>
<ul>
<li>载荷的格式配置参数全都是声明的，参与者 MUST 使用在session中被提供的配置</li>
<li>通过声明多个 RTP 载荷类型，一个以上的配置可能被提供。在这种情况下，receivers 应当选择一个最适合的 repair flow</li>
</ul>
<h1 id="6-Protection-and-Recovery-Procedures-Parity-Codes-保护和恢复过程-奇偶码"><a href="#6-Protection-and-Recovery-Procedures-Parity-Codes-保护和恢复过程-奇偶码" class="headerlink" title="6. Protection and Recovery Procedures - Parity Codes 保护和恢复过程 - 奇偶码"></a>6. Protection and Recovery Procedures - Parity Codes 保护和恢复过程 - 奇偶码</h1><p>这一章提供了对 1-D 和 2-D 奇偶码的完整定义和它们的 RTP 载荷格式</p>
<h2 id="6-1-Overview-概览"><a href="#6-1-Overview-概览" class="headerlink" title="6.1. Overview 概览"></a>6.1. Overview 概览</h2><p>下面的章节详细介绍了生成修复包、通过修复包重建源包的具体步骤。</p>
<h2 id="6-2-Repair-Packet-Construction-修复包的构造"><a href="#6-2-Repair-Packet-Construction-修复包的构造" class="headerlink" title="6.2. Repair Packet Construction 修复包的构造"></a>6.2. Repair Packet Construction 修复包的构造</h2><p>修复包的头部已经在 Section 4.2 有了详细说明</p>
<p>FEC 的头部包含 12 字节（有可能扩展到 28 字节）。通过对每个源包的每一位进行异或操作来生成特定的修复包。给你一个修复包，那么源包的集合，可以通过 Section 6.3.1 中的公式计算出来。</p>
<p>通过将每个源包按照以下字段的顺序拼接在一起，我们就可以生成 bit string。</p>
<ul>
<li><p>RTP 头部的前 64 bits </p>
</li>
<li><p>无符号网络序的 16-bit 源包字节大小除以12（因为固定的RTP头）。说人话就是网络序的 uin16_t 的变量 = 源包字节数 / 12</p>
<p>比如以下参数的长度和（如果有的话）：CSRC list，extension header, RTP payload 和 RTP padding (16 bits).</p>
</li>
</ul>
<p>通过对源包的 bit string 应用奇偶操作，我们就可以生成 FEC bit string。</p>
<p>FEC 头是从 FEC bit string 按照以下结构生成的：</p>
<ul>
<li>忽略掉 FEC bit string 中的 2 bits 最高有效位。设置 FEC 头的 MSK bits 成合适的值，比如，它跟 bitmask 长度有关</li>
<li>FEC bit string 的下一位 被写入FEC头的 P recovery bit</li>
<li>下 1 位被写入 FEC 头的 X recovery bit</li>
<li>下 4 位被写入 FEC 头的 CC recovery field</li>
<li>下 1 位被写入 FEC 头的 M recovery bit</li>
<li>下 7 位被写入 FEC 头的 PT recovery field</li>
<li>下 16 位被跳过</li>
<li>下 32 位被写入 FEC 头的 TS recovery field</li>
<li>下 16 位被写入 FEC 头的 length recovery field</li>
<li>根据选择的 MSK 值， bit mask of appropriate length will be set to the appropriate values.</li>
</ul>
<p>就像 Section 4.2 中描述的那样，FEC 头部的 SN base field 必须设置成 the lowest sequence number of the source packets protected by this repair packet. 当 MSK 表示一个 bitmask（MSK=00,01,10）的时候，SN base field corresponds to the lowest sequence number indicated in the bitmask. 当 MSK=11，以下的情况：</p>
<ol>
<li>对于 interleaved FEC 包，这对应着源包的最低 sequence number，按照列进行构建</li>
<li>对于 non-interleaved FEC 包，SN base field 必须设置成源包的最低 sequence number，按照行进行构建。</li>
</ol>
<p>修复包的载荷数据包含了源包 XOR 之后的数据。如果源包的载荷长度各不相同，那么短的包必须补零补到长的包那么长。</p>
<p>由于这种可能的 padding 和 强制的 FEC 头，一个修复包的大小要比源包的大。<strong>这可能导致修复包的大小超过 MTU。</strong></p>
<h2 id="6-3-Source-Packet-Reconstruction-重建源包"><a href="#6-3-Source-Packet-Reconstruction-重建源包" class="headerlink" title="6.3. Source Packet Reconstruction 重建源包"></a>6.3. Source Packet Reconstruction 重建源包</h2><p>这一小节描述了重建丢失源包的修复过程。</p>
<p>修复过程有两步：</p>
<ol>
<li>FEC decoder 决定应该使用哪一个源包和修复包来恢复丢失的包</li>
<li>decoder 修复丢失的包，包括 RTP 头部和 RTP 载荷</li>
</ol>
<p>在下面几个小节，我们描述了一些步骤一和步骤二的 RECOMMENDED 的算法。基于这个实现，某些算法可能会被抛弃使用。</p>
<p>然而，最终实现 MUST 与下面的描述一致。</p>
<p>注意，不管 FEC 保护应用在行还是列，1-D 奇偶码所使用的算法相同。而 2-D奇偶码，通常需要多次迭代，这个迭代解码算法被 Section 6.3.4 进一步解释。</p>
<h3 id="6-3-1-Associating-the-Source-and-Repair-Packets-源包与修复包之间的关联"><a href="#6-3-1-Associating-the-Source-and-Repair-Packets-源包与修复包之间的关联" class="headerlink" title="6.3.1. Associating the Source and Repair Packets 源包与修复包之间的关联"></a>6.3.1. Associating the Source and Repair Packets 源包与修复包之间的关联</h3><p>根据<strong>修复包</strong> p<em>，得出<strong>源包</strong>的集合 T(p\</em>)。</p>
<p>注意的是，对于 L 列、 D 行的 source block， 集合 T 包含了 D 个源包 + 一个列修复包，还有 L 个源包 + 一个行修复包</p>
<p>列修复包：通过一列源包计算出来的修复包</p>
<p>行修复包：通过一行源包计算出来的修复包</p>
<p>集合 T 中如果只丢了一个源包，那么数据可以被恢复。如果集合 T 中丢失超过一个源包，那么 1-D FEC protection 将失效。</p>
<h4 id="6-3-1-1-Signaled-in-SDP-在SDP中的交互"><a href="#6-3-1-1-Signaled-in-SDP-在SDP中的交互" class="headerlink" title="6.3.1.1. Signaled in SDP 在SDP中的交互"></a>6.3.1.1. Signaled in SDP 在SDP中的交互</h4><p>第一步是关联源包和修复包。如果 endpoint 整个依赖 out-of-band signaling（MSK=11, M=N=0），可以从 SDP 描述的 media type parameters 推断出这个信息。进一步来讲，RTP 头部的 payload type field 可以辅助 receiver 去 distinguish 交错的或非交错的 FEC 包。</p>
<p>数学上来讲，对于接收到的任意的修复包 p<em>， 我们可以确定出被保护的源包的 sequence number：<br>$$<br>p</em>_snb + i \times {X_1} \left( modulo 65535 \right)<br>$$<br>p*_snb 表示 p* 的 FEC 头，里面的 SN base filed 的。</p>
<p>X_1，如果 FEC 包是交错式的，就被设置成 L，如果是非交错式的，那就是 1<br>$$<br>0 \le i \lt X_2<br>$$<br>X_2，如果 FEC 包是交错式的，就被设置成 D，如果是非交错式的，那就是 L</p>
<h4 id="6-3-1-2-Using-bitmasks"><a href="#6-3-1-2-Using-bitmasks" class="headerlink" title="6.3.1.2. Using bitmasks"></a>6.3.1.2. Using bitmasks</h4><p>当使用固定大小的 bitmasks （16-, 48-, 122-bits）的时候，FEC 头部的 SN base field 表示 lowest sequence number of the 源包 that forms the FEC packet. </p>
<p>bitmask 中的 “1” 其实是从 SN base 开始的 offset，表示被 FEC 保护的剩余 packet。</p>
<p>bitmasks 有能力表示任意的 protection patterns，比如 1-D interleaved，1-D non-interleaved, 2-D, staircase。</p>
<h4 id="6-3-1-3-Using-M-and-Offsets"><a href="#6-3-1-3-Using-M-and-Offsets" class="headerlink" title="6.3.1.3. Using M and Offsets"></a>6.3.1.3. Using M and Offsets</h4><p>当 M 的值非零时，8-bit 的 field 表示由 interleaved（N&gt;0） 或 non-interleaved（N=0） FEC 包所保护的数据包的 offset </p>
<p>通过组合 interleaved 和 non-interleaved FEC包，我们可以组成 2-D protection patterns。</p>
<p>数学上来讲，对于任意接收到的修复包 p*，我们可以通过以下方式确定被保护的源包的 sequence number：</p>
<pre class="line-numbers language-none"><code class="language-none">When N &#x3D; 0:
  p*_snb, p*_snb+1,..., p*_snb+(M-1), p*_snb+M
When N &gt; 0:
  p*_snb, p*_snb+(Mx1), p*_snb+(Mx2),..., p*_snb+(Mx(N-1)), p*_snb+(MxN)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="6-3-2-Recovering-the-RTP-Header-恢复-RTP-头"><a href="#6-3-2-Recovering-the-RTP-Header-恢复-RTP-头" class="headerlink" title="6.3.2. Recovering the RTP Header 恢复 RTP 头"></a>6.3.2. Recovering the RTP Header 恢复 RTP 头</h3><p>略过，因为不需要实现</p>
<h1 id="7-SDP-Examples-有关-SDP-的例子"><a href="#7-SDP-Examples-有关-SDP-的例子" class="headerlink" title="7. SDP Examples 有关 SDP 的例子"></a>7. SDP Examples 有关 SDP 的例子</h1><p>这一节，提供了两个 SDP 的例子。例子里使用了在 RFC5956 中定义的 FEC grouping 语义。</p>
<h2 id="7-1-Example-SDP-for-Flexible-FEC-Protection-with-in-band-SSRC-mapping"><a href="#7-1-Example-SDP-for-Flexible-FEC-Protection-with-in-band-SSRC-mapping" class="headerlink" title="7.1. Example SDP for Flexible FEC Protection with in-band SSRC mapping"></a>7.1. Example SDP for Flexible FEC Protection with in-band SSRC mapping</h2><p>在这个例子里，我们有一个视频源流和一个FEC修复包流。源和修复包流被复用在不同的SSRC里。repair-window被设置成 200ms</p>
<pre class="line-numbers language-none"><code class="language-none">v&#x3D;0
o&#x3D;mo 1122334455 1122334466 IN IP4 fec.example.com
s&#x3D;FlexFEC minimal SDP signalling Example
t&#x3D;0 0
m&#x3D;video 30000 RTP&#x2F;AVP 96 98
c&#x3D;IN IP4 143.163.151.157
a&#x3D;rtpmap:96 VP8&#x2F;90000
a&#x3D;rtpmap:98 flexfec&#x2F;90000
a&#x3D;fmtp:98; repair-window&#x3D;200ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="7-2-Example-SDP-for-Flex-FEC-Protection-with-explicit-signalling-in-the-SDP"><a href="#7-2-Example-SDP-for-Flex-FEC-Protection-with-explicit-signalling-in-the-SDP" class="headerlink" title="7.2. Example SDP for Flex FEC Protection with explicit signalling in the SDP"></a>7.2. Example SDP for Flex FEC Protection with explicit signalling in the SDP</h2><p>在这里例子里，我们有一个视频源流（ssrc：1234）和一个 FEC 修复包流（ssrc：2345）。</p>
<p>我们跟<code>a=ssrc-group:FEC-FR 1234 2345</code>构建一个 FEC groups。源和修复包流复用在不同的 SSRC 里。repair-window 被设置成 200ms</p>
<pre class="line-numbers language-none"><code class="language-none">v&#x3D;0
o&#x3D;ali 1122334455 1122334466 IN IP4 fec.example.com
s&#x3D;2-D Parity FEC with no in band signalling Example
t&#x3D;0 0
m&#x3D;video 30000 RTP&#x2F;AVP 100 110
c&#x3D;IN IP4 233.252.0.1&#x2F;127
a&#x3D;rtpmap:100 MP2T&#x2F;90000
a&#x3D;rtpmap:110 flexfec&#x2F;90000
a&#x3D;fmtp:110 L:5; D:10; ToP:2; repair-window:200000
a&#x3D;ssrc:1234
a&#x3D;ssrc:2345
a&#x3D;ssrc-group:FEC-FR 1234 2345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="8-Congestion-Control-Considerations-拥塞控制的考虑"><a href="#8-Congestion-Control-Considerations-拥塞控制的考虑" class="headerlink" title="8. Congestion Control Considerations 拥塞控制的考虑"></a>8. Congestion Control Considerations 拥塞控制的考虑</h1><p>FEC 为应用层对抗丢包提供了一种有效的方法。然而，如果在一个丢包是因为拥塞控制的网络中，那么在使用 FEC 之前，应该考虑到 FEC 注入到网络中潜在的影响。</p>
<p>特别的是，在带宽限制的网络中，FEC 修复包的流动，可能成为带宽消耗的罪魁祸首，有可能会堵塞网络。在这个情况里，应用程序 MUST NOT 随意增加 FEC 保护的次数，因为这么做会有可能导致拥塞崩溃（Congestion Collapse）。</p>
<p>Congestive collapse (or congestion collapse) is the condition in which congestionprevents or limits useful communication.</p>
<p>如果你真的很想要 FEC 保护，那么你或许可以在源码率降低的时候采用更强的 FEC 保护。</p>
<p>在一个网络友好的实现里，如果应用程序知道 发送/接受 FEC 修复流 并不能帮助恢复丢失的包的时候，应用程序 SHOULD NOT 发送/接收 FEC 修复流。然而，如果考虑用于带宽估计，而不是通过推测方式探寻额外的容量，应用程序 MAY still continue 去使用 FEC。这里 RECOMMENDED 去基于应用程序观察到的丢包率，动态地调整 FEC 保护。</p>
<p>在多播的情景里，为每一个接收端去优化 FEC 保护是非常困难的。如果你有一堆不同的接受者，并且这些接受者都要求使用不同的 FEC 保护级别的话，这里 RECOMMENDED 发送者提供多个修复流，每个修复流都是不同的 FEC 保护级别，让接受者加入对应的多播session 去接收最适合他们的修复流。</p>
<p>编者注：2-D的奇偶码应该也加入到 “多余的拥塞控制考虑” 里</p>
<p>（不是译者注）</p>
<h1 id="9-Security-Considerations-安全考虑"><a href="#9-Security-Considerations-安全考虑" class="headerlink" title="9. Security Considerations 安全考虑"></a>9. Security Considerations 安全考虑</h1><h1 id="10-IANA-Considerations"><a href="#10-IANA-Considerations" class="headerlink" title="10. IANA Considerations"></a>10. IANA Considerations</h1><pre class="line-numbers language-none"><code class="language-none">New media subtypes are subject to IANA registration.  For the
registration of the payload formats and their parameters introduced
in this document, refer to Section 5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h1 id="11-Acknowledgements"><a href="#11-Acknowledgements" class="headerlink" title="11. Acknowledgements"></a>11. Acknowledgements</h1><pre class="line-numbers language-none"><code class="language-none">Some parts of this document are borrowed from [RFC5109].  Thus, the
author would like to thank the editor of [RFC5109] and those who
contributed to [RFC5109].

Thanks to Bernard Aboba , Rasmus Brandt , Roni Even , Stefan Holmer ,
Jonathan Lennox , and Magnus Westerlund for providing valuable
feedback on earlier versions of this draft.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>剩下的我就不翻译了</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/27/2020-06-27-STUN/" rel="prev" title="RFC5389 - Session Traversal Utilities for NAT 翻译">
                  <i class="fa fa-chevron-left"></i> RFC5389 - Session Traversal Utilities for NAT 翻译
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/04/2020-08-04-FEC/" rel="next" title="FEC - 前向纠错技术">
                  FEC - 前向纠错技术 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junyi</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  



    <div class="pjax">


<script>
NexT.utils.loadComments('.utterances-container', () => {
  const script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', "Military-Doctor/Military-Doctor.github.io");
  script.setAttribute('issue-term', "pathname");
  script.setAttribute('theme', "preferred-color-scheme");
  script.crossOrigin = 'anonymous';
  script.async = true;
  document.querySelector('.utterances-container').appendChild(script);
});
</script>

    </div>
</body>
</html>
